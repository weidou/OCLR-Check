import 'platform:/resource/lu.svv.offline/models/tempsy.ecore#/'
import 'platform:/resource/lu.svv.offline/models/trace.ecore#/'
import 'platform:/resource/lu.svv.offline/models/check.ecore#/'

package check

context Monitor

--------------------  Scopes  ----------------------

def: ordinalIndexOf(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer):Integer =
let result:Tuple(index:Integer, ordinal:Integer) = trace->iterate(elem:trace::TraceElement;
  iter:Tuple(index:Integer, ordinal:Integer) = Tuple{index:Integer = 0, ordinal:Integer = 0}
  |
  if iter.ordinal = n then
    iter
  else
    if elem.event = eventName then
      Tuple{index:Integer = iter.index + 1, ordinal:Integer = iter.ordinal + 1}
    else
      Tuple{index:Integer = iter.index + 1, ordinal:Integer = iter.ordinal}
    endif
  endif
)
in
if result.ordinal = n then
  result.index
else
  -1
endif

def: atLeastBefore(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):OrderedSet(trace::TraceElement) =
--return the scope of 'before [n] eventName at least timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n) in
if 1 <> position.abs() then
  if 1 = timeDistance then
    trace->subOrderedSet(1, position-1)
  else
    let toTimeStamp:Integer = trace->at(position).timestamp in 
    trace->select(elem | toTimeStamp - timeDistance >= elem.timestamp) 
  endif
else
  OrderedSet{}
endif

def: atMostBefore(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):OrderedSet(trace::TraceElement) =
--return the scope of 'before [n] eventName at most timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n) in
if -1 <> position then
  let toTimeStamp:Integer = trace->at(position).timestamp in 
  trace->select(elem | toTimeStamp - timeDistance <= elem.timestamp and toTimeStamp >= elem.timestamp)
else
  OrderedSet{}
endif

def: exactlyBefore(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):OrderedSet(trace::TraceElement) =
--return the scope of 'before [n] eventName exactly timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n) in
if -1 <> position then
  let toTimeStamp:Integer = trace->at(position).timestamp in 
  trace->select(elem | toTimeStamp - timeDistance = elem.timestamp)
else
  OrderedSet{}
endif

def: applyScopeBefore(trace:trace::Trace, scope:tempsy::Scope):OrderedSet(trace::TraceElement) =
--return the scope of 'before boundary'
--'boundary' : '[n] eventName [comparingOperator timeDistance tu]'
let boundary:tempsy::Boundary = scope.oclAsType(tempsy::UniScope).boundary, eventName:String = boundary.event.name in
if boundary.timeDistance->notEmpty() then
  let comparingOperator:tempsy::ComparingOperator = boundary.timeDistance.comparingOperator, timeDistance:Integer = boundary.timeDistance.value in
  if boundary.ordinal > 0 then
    let n:Integer = boundary.ordinal in
    if tempsy::ComparingOperator::ATLEAST = comparingOperator then
      self.atLeastBefore(trace.traceElements, eventName,n,timeDistance) 
    else
      if tempsy::ComparingOperator::ATMOST = comparingOperator then
        self.atMostBefore(trace.traceElements, eventName,n,timeDistance)
      else
        self.exactlyBefore(trace.traceElements, eventName,n,timeDistance)
      endif
    endif
  else
    if tempsy::ComparingOperator::ATLEAST = comparingOperator then
      self.atLeastBefore(trace.traceElements, eventName,1,timeDistance)
    else
      if tempsy::ComparingOperator::ATMOST = comparingOperator then
        self.atMostBefore(trace.traceElements, eventName,1,timeDistance)
      else
        self.exactlyBefore(trace.traceElements, eventName,1,timeDistance)
      endif
    endif
  endif
else
  if boundary.ordinal > 0 then
    let n:Integer = boundary.ordinal in
    self.atLeastBefore(trace.traceElements, eventName,n,1)
  else
    self.atLeastBefore(trace.traceElements, eventName,1,1)
  endif
endif

def: atLeastAfter(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):OrderedSet(trace::TraceElement) =
--return the scope of 'after [n] eventName at least timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n), size:Integer = trace->size() in
if -1 <> position and size <> position then
  if 1 = timeDistance then
    trace->subOrderedSet(position+1, size)
  else
    let fromTimeStamp:Integer = trace->at(position).timestamp in 
    trace->select(elem | fromTimeStamp + timeDistance <= elem.timestamp)
  endif
else
  OrderedSet{}
endif

def: atMostAfter(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):OrderedSet(trace::TraceElement) =
--return the scope of 'after [n] eventName at most timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n) in
if -1 <> position then
  let fromTimeStamp:Integer = trace->at(position).timestamp in 
  trace->select(elem | fromTimeStamp <= elem.timestamp and fromTimeStamp + timeDistance >= elem.timestamp)
else
  OrderedSet{}
endif

def: exactlyAfter(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):OrderedSet(trace::TraceElement) =
--return the scope of 'after [n] eventName exactly timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n) in
if -1 <> position then
  let fromTimeStamp:Integer = trace->at(position).timestamp in 
  trace->select(elem | fromTimeStamp + timeDistance = elem.timestamp)
else
  OrderedSet{}
endif

def: applyScopeAfter(trace:trace::Trace, scope:tempsy::Scope):OrderedSet(trace::TraceElement) =
--return the scope of 'after boundary'
--'boundary' : '[n] eventName [comparingOperator timeDistance tu]'
let boundary:tempsy::Boundary = scope.oclAsType(tempsy::UniScope).boundary, eventName:String = boundary.event.name in
if boundary.timeDistance->notEmpty() then
  let comparingOperator:tempsy::ComparingOperator = boundary.timeDistance.comparingOperator, timeDistance:Integer = boundary.timeDistance.value in
  if boundary.ordinal > 0 then
      let n:Integer = boundary.ordinal in
    if tempsy::ComparingOperator::ATLEAST = comparingOperator then
      self.atLeastAfter(trace.traceElements, eventName, n, timeDistance)
    else if tempsy::ComparingOperator::ATMOST = comparingOperator then
        self.atMostAfter(trace.traceElements, eventName,n,timeDistance)
      else 
        self.exactlyAfter(trace.traceElements, eventName, n, timeDistance)
      endif 
    endif
  else
    if tempsy::ComparingOperator::ATLEAST = comparingOperator then
      self.atLeastAfter(trace.traceElements, eventName, 1,timeDistance)
    else if tempsy::ComparingOperator::ATMOST = comparingOperator then
        self.atMostAfter(trace.traceElements, eventName, 1, timeDistance)
      else 
        self.exactlyAfter(trace.traceElements, eventName, 1, timeDistance)
      endif 
    endif     
  endif
else
  if boundary.ordinal > 0 then
      let n:Integer = boundary.ordinal in
    self.atLeastAfter(trace.traceElements, eventName, n, 1)         
    else  
    self.atLeastAfter(trace.traceElements, eventName, 1, 1)
  endif
endif

def: applySpecialBetweenAnd(trace:OrderedSet(trace::TraceElement), eventNameBegin:String, nBegin:Integer, timeDistanceBegin:Integer, eventNameEnd:String, nEnd:Integer, timeDistanceEnd:Integer):OrderedSet(trace::TraceElement) = 
--return the scope of 'between nBegin eventNameBegin at least timeDistanceBegin tu and nBegin eventNameEnd at least timeDistanceEnd tu'
let t:Tuple(index:Integer, indexBegin:Integer, indexEnd:Integer, count:Integer) = trace->iterate(elem:trace::TraceElement;
    iter:Tuple(index:Integer, indexBegin:Integer, indexEnd:Integer, count:Integer) = Tuple{index:Integer = 0, indexBegin:Integer = 0, indexEnd:Integer = 0, count:Integer = 0} |
    if iter.indexBegin = 0 then
      let currentIndex:Integer = iter.index + 1 in
      if elem.event = eventNameBegin then
        let currentBeginCount:Integer = iter.count+1 in
        if currentBeginCount = nBegin then
          Tuple{index:Integer = currentIndex, indexBegin:Integer = currentIndex + 1, indexEnd:Integer = iter.indexEnd, count:Integer = 0}
        else
          Tuple{index:Integer = currentIndex, indexBegin:Integer = iter.indexBegin, indexEnd:Integer = iter.indexEnd, count:Integer = currentBeginCount}
        endif
      else
        Tuple{index:Integer = currentIndex, indexBegin:Integer = iter.indexBegin, indexEnd:Integer = iter.indexEnd, count:Integer = iter.count}
      endif
    else
      if iter.indexEnd = 0 then
        let currentIndex:Integer = iter.index + 1 in
        if elem.event = eventNameEnd then
          let currentEndCount:Integer = iter.count+1 in
          if currentEndCount = nEnd then
            Tuple{index:Integer = currentIndex, indexBegin:Integer = iter.indexBegin, indexEnd:Integer = currentIndex-1, count:Integer = nEnd}  
          else
            Tuple{index:Integer = currentIndex, indexBegin:Integer = iter.indexBegin, indexEnd:Integer = iter.indexEnd, count:Integer = currentEndCount}
          endif
        else
          Tuple{index:Integer = currentIndex, indexBegin:Integer = iter.indexBegin, indexEnd:Integer = iter.indexEnd, count:Integer = iter.count}
        endif
      else
        iter
      endif
    endif
  )
in
let
  i:Integer = t.indexBegin,
  j:Integer = t.indexEnd,
  timestampBegin:Integer = trace->at(i-1).timestamp+timeDistanceBegin,
  timestampEnd:Integer = trace->at(j+1).timestamp-timeDistanceEnd
in
if i > 0 and j > 0 and i <= j then
  if timeDistanceBegin = 1 and timeDistanceEnd = 1 then
    trace->subOrderedSet(i, j)
  else
    trace->subOrderedSet(i, j)->select(elem | elem.timestamp >= timestampBegin and elem.timestamp <= timestampEnd)
  endif
else
  OrderedSet{}
endif

def: applyOriginalBetweenAnd(trace:OrderedSet(trace::TraceElement), eventNameBegin:String, eventNameEnd:String):Sequence(OrderedSet(trace::TraceElement)) =
--return the scope of 'between eventNameBegin and eventNameEnd'
trace->iterate(elem:trace::TraceElement;
  iter:Tuple(index:Integer, result:Sequence(OrderedSet(trace::TraceElement)), i:Integer)
  =Tuple{index:Integer = 0, result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, i:Integer = 0} |
  if iter.i = 0 then
    let currentIndex:Integer = iter.index + 1 in
    if elem.event = eventNameBegin then
      Tuple{index:Integer = currentIndex, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = currentIndex}
    else
      Tuple{index:Integer = currentIndex, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = iter.i}
    endif
  else
    if elem.event = eventNameEnd then
      let i:Integer = iter.i+1, j:Integer = iter.index in
      if i <= j then
        Tuple{index:Integer = j + 1, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result->append(trace->subOrderedSet(i, j)), i:Integer = 0}
      else
        Tuple{index:Integer = j + 1, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = 0}
      endif
    else
      Tuple{index:Integer = iter.index + 1, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = iter.i}
    endif
  endif
).result


def: applyOriginalBetweenAnd(trace:OrderedSet(trace::TraceElement), eventNameBegin:String, distanceBegin:Integer, eventNameEnd:String):Sequence(OrderedSet(trace::TraceElement)) =
--return the scope of 'between eventNameBegin at least distanceBegin tu and eventNameEnd'
trace->iterate(elem:trace::TraceElement;
  iter:Tuple(index:Integer, result:Sequence(OrderedSet(trace::TraceElement)), i:Integer, criticalTime:Integer)
  =Tuple{index:Integer = 0, result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, i:Integer = 0, criticalTime:Integer = 0} |
  let e:String = elem.event in
  if iter.i = 0 then
    let currentIndex:Integer = iter.index + 1 in
    if e = eventNameBegin then
      Tuple{index:Integer = currentIndex, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = currentIndex, criticalTime:Integer = elem.timestamp + distanceBegin}
    else
      Tuple{index:Integer = currentIndex, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = iter.i, criticalTime:Integer = iter.criticalTime}
    endif
  else
    if e = eventNameEnd then
      let t:Integer = elem.timestamp, i:Integer = iter.i + 1, j:Integer = iter.index, t1:Integer = iter.criticalTime in
      if i <= j and t1 < t then
        Tuple{index:Integer = j + 1, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result->append(trace->subOrderedSet(i, j)->select(segElem | segElem.timestamp >= t1)), i:Integer = 0, criticalTime:Integer = iter.criticalTime}
      else
        Tuple{index:Integer = j + 1, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = 0, criticalTime:Integer = iter.criticalTime}
      endif
    else
      Tuple{index:Integer = iter.index + 1, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = iter.i, criticalTime:Integer = iter.criticalTime}
    endif
  endif
).result

def: applyOriginalBetweenAnd(trace:OrderedSet(trace::TraceElement), eventNameBegin:String, eventNameEnd:String, distanceEnd:Integer):Sequence(OrderedSet(trace::TraceElement)) =
--return the scope of 'between eventNameBegin and at least distanceEnd tu eventNameEnd'
trace->iterate(elem:trace::TraceElement;
  iter:Tuple(index:Integer, result:Sequence(OrderedSet(trace::TraceElement)), i:Integer, criticalTime:Integer)
  =Tuple{index:Integer = 0, result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, i:Integer = 0, criticalTime:Integer = 0} |
  let e:String = elem.event in
  if iter.i = 0 then
    let currentIndex:Integer = iter.index + 1 in
    if e = eventNameBegin then
      Tuple{index:Integer = currentIndex, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = currentIndex, criticalTime:Integer = elem.timestamp + 1}
    else
      Tuple{index:Integer = currentIndex, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = iter.i, criticalTime:Integer = iter.criticalTime}
    endif
  else
    if e = eventNameEnd then
      let t:Integer = elem.timestamp, i:Integer = iter.i + 1, j:Integer = iter.index, t1:Integer = iter.criticalTime, t2:Integer = t - distanceEnd in
      if i <= j and t1 <= t2 then
        Tuple{index:Integer = j + 1, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result->append(trace->subOrderedSet(i, j)->select(segElem | segElem.timestamp <= t2)), i:Integer = 0, criticalTime:Integer = iter.criticalTime}
      else
        Tuple{index:Integer = j + 1, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = 0, criticalTime:Integer = iter.criticalTime}
      endif
    else
      Tuple{index:Integer = iter.index + 1, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = iter.i, criticalTime:Integer = iter.criticalTime}
    endif
  endif
).result

def: applyOriginalBetweenAnd(trace:OrderedSet(trace::TraceElement), eventNameBegin:String, distanceBegin:Integer, eventNameEnd:String, distanceEnd:Integer):Sequence(OrderedSet(trace::TraceElement)) =
--return the scope of 'between eventNameBegin at least distanceBegin tu and at least distanceEnd tu eventNameEnd'
trace->iterate(elem:trace::TraceElement;
  iter:Tuple(index:Integer, result:Sequence(OrderedSet(trace::TraceElement)), i:Integer, criticalTime:Integer)
  =Tuple{index:Integer = 0, result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, i:Integer = 0, criticalTime:Integer = 0} |
  let e:String = elem.event in
  if iter.i = 0 then
    let currentIndex:Integer = iter.index + 1 in
    if e = eventNameBegin then
      Tuple{index:Integer = currentIndex, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = currentIndex, criticalTime:Integer = elem.timestamp + distanceBegin}
    else
      Tuple{index:Integer = currentIndex, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = iter.i, criticalTime:Integer = iter.criticalTime}
    endif
  else
    if e = eventNameEnd then
      let t:Integer = elem.timestamp, i:Integer = iter.i + 1, j:Integer = iter.index, t1:Integer = iter.criticalTime, t2:Integer = t - distanceEnd in
      if i <= j and t1 <= t2 then
        Tuple{index:Integer = j + 1, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result->append(trace->subOrderedSet(i, j)->select(segElem | segElem.timestamp >= t1 and segElem.timestamp <= t2)), i:Integer = 0, criticalTime:Integer = iter.criticalTime}
      else
        Tuple{index:Integer = j + 1, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = 0, criticalTime:Integer = iter.criticalTime}
      endif
    else
      Tuple{index:Integer = iter.index + 1, result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = iter.i, criticalTime:Integer = iter.criticalTime}
    endif
  endif
).result

def: applyScopeBetweenAnd(trace:trace::Trace, scope:tempsy::Scope):Sequence(OrderedSet(trace::TraceElement)) = 
--return the scope of 'between boundaryBegin and boundaryEnd'
--i.e., 'between [nBegin] eventNameBegin [at least timeDistanceBegin] and [nEnd] eventNameEnd [at least timeDistanceEnd]'
let boundaryBegin:tempsy::Boundary = scope.oclAsType(tempsy::BiScope).boundaryBegin,
  boundaryEnd:tempsy::Boundary = scope.oclAsType(tempsy::BiScope).boundaryEnd,
  eventNameBegin:String = boundaryBegin.event.name,
  eventNameEnd:String = boundaryEnd.event.name
in
if boundaryBegin.timeDistance->notEmpty() then
  let timeDistanceBegin:Integer = boundaryBegin.timeDistance.value in 
  if boundaryEnd.timeDistance->notEmpty() then
    let timeDistanceEnd:Integer = boundaryEnd.timeDistance.value in
    if boundaryBegin.ordinal > 0 then
      let result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, nBegin:Integer = boundaryBegin.ordinal in
      if boundaryEnd.ordinal > 0 then
        let nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, timeDistanceBegin, eventNameEnd, nEnd, timeDistanceEnd))
      else
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, timeDistanceBegin, eventNameEnd, 1, timeDistanceEnd))
      endif
    else
      if boundaryEnd.ordinal > 0 then
        let result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, 1, timeDistanceBegin, eventNameEnd, nEnd, timeDistanceEnd))
      else
        self.applyOriginalBetweenAnd(trace.traceElements, eventNameBegin, timeDistanceBegin, eventNameEnd, timeDistanceEnd)
      endif
    endif
  else
    if boundaryBegin.ordinal > 0 then
      let result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, nBegin:Integer = boundaryBegin.ordinal in
      if boundaryEnd.ordinal > 0 then
        let nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, timeDistanceBegin, eventNameEnd, nEnd, 1))
      else
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, timeDistanceBegin, eventNameEnd, 1, 1))
      endif
    else
      if boundaryEnd.ordinal > 0 then
        let result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, 1, timeDistanceBegin, eventNameEnd, nEnd, 1))
      else
        self.applyOriginalBetweenAnd(trace.traceElements, eventNameBegin, timeDistanceBegin, eventNameEnd)
      endif
    endif
  endif
else
  if boundaryEnd.timeDistance->notEmpty() then
    let timeDistanceEnd:Integer = boundaryEnd.timeDistance.value in
    if boundaryBegin.ordinal > 0 then
      let result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, nBegin:Integer = boundaryBegin.ordinal in
      if boundaryEnd.ordinal > 0 then
        let nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, 1, eventNameEnd, nEnd, timeDistanceEnd))
      else
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, 1, eventNameEnd, 1, timeDistanceEnd))
      endif
    else
      if boundaryEnd.ordinal > 0 then
        let result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, 1, 1, eventNameEnd, nEnd, timeDistanceEnd))
      else
        self.applyOriginalBetweenAnd(trace.traceElements, eventNameBegin, eventNameEnd, timeDistanceEnd)
      endif
    endif
  else
    if boundaryBegin.ordinal > 0 then
      let result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, nBegin:Integer = boundaryBegin.ordinal in
      if boundaryEnd.ordinal > 0 then
        let nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, 1, eventNameEnd, nEnd, 1))
      else
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, 1, eventNameEnd, 1, 1))
      endif
    else
      if boundaryEnd.ordinal > 0 then
        let result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, 1, 1, eventNameEnd, nEnd, 1))
      else
        self.applyOriginalBetweenAnd(trace.traceElements, eventNameBegin, eventNameEnd)
      endif
    endif
  endif
endif

def: applyScopeGlobally(trace:trace::Trace, scope:tempsy::Scope):OrderedSet(trace::TraceElement) = 
trace.traceElements

--------------------  Patterns  ----------------------

--NEW since 05/02/2015

def: compare(a:Integer, b:Integer, which:Integer):Boolean =
if which = 1 then --at least b tu
  a >= b
else
  if which = 2 then --at most b tu
    a <= b
  else
    if which = 3 then --exactly b tu
      a = b
    else
      true --no comparison is needed
    endif
  endif
endif

def: loadDistances(distances:Sequence(tempsy::TimeDistance)):Sequence(Tuple(which:Integer, value:Integer)) =
if distances->forAll(elem | elem->isEmpty()) then
  Sequence{}
else
  distances->iterate(elem:tempsy::TimeDistance; iter:Sequence(Tuple(which:Integer, value:Integer)) = Sequence{} |
    if elem->isEmpty() then
      iter->append(Tuple{which:Integer = 0, value:Integer = 1})
    else
      if tempsy::ComparingOperator::ATLEAST = elem.comparingOperator then
        iter->append(Tuple{which:Integer = 1, value:Integer = elem.value})
      else
        if tempsy::ComparingOperator::ATMOST = elem.comparingOperator then
          iter->append(Tuple{which:Integer = 2, value:Integer = elem.value})
        else
          iter->append(Tuple{which:Integer = 3, value:Integer = elem.value})
        endif
      endif
    endif
  )
endif

-- modified on 21/04/2015
def: checkPatternResponseOneOnePlain(subtrace:OrderedSet(trace::TraceElement), cause:String, effect:String):Boolean =
subtrace->iterate(
  elem:trace::TraceElement;
  result:Boolean = true
  |
  let e:String = elem.event in
  if e = cause then
    false
  else
    if e = effect then
      true
    else
      result
    endif
  endif
)

-- modified on 21/04/2015
def: checkPatternResponseOneOneAtLeastMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effect:String):Boolean =
subtrace->iterate(elem:trace::TraceElement;
  midCriticalInstant:Integer = 0
  |
  let e:String = elem.event in
  if e = cause then
    elem.timestamp + distance
  else
    if e = effect and elem.timestamp >= midCriticalInstant then
      0
    else
      midCriticalInstant
    endif
  endif
) = 0

-- modified on 12/06/2015
def: checkPatternResponseOneOneAtMostMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effect:String):Boolean =
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.midCriticalInstant = 0 and e = cause then
      Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + distance}
    else
      if e = effect then
        if elem.timestamp <= iter.midCriticalInstant then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = 0}
        else
          Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1} -- violation
        endif
      else
        iter
      endif
    endif
  else
    iter
  endif
).midCriticalInstant = 0

-- modified on 21/01/2016
def: checkPatternResponseOneOneExactlyMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effect:String):Boolean =
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer))
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}}
  |
  if iter.flag then
    let e:String = elem.event in
    if e = cause then
      Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(elem.timestamp + distance)}
    else
      if e = effect and iter.midCriticalInstants->notEmpty() and elem.timestamp >= iter.midCriticalInstants->first() then
        let t:Integer = elem.timestamp in
        if t = iter.midCriticalInstants->first() then
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(t)}
        else
          Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants}
        endif
      else
        iter
      endif
    endif
  else
    iter
  endif
).midCriticalInstants->isEmpty()

def: checkPatternResponseOneOneMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:tempsy::TimeDistance, effect:String):Boolean =
let value:Integer = distance.value, which:tempsy::ComparingOperator = distance.comparingOperator in
if which = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternResponseOneOneAtLeastMid(subtrace, cause, value, effect)
else
  if which = tempsy::ComparingOperator::ATMOST then
    self.checkPatternResponseOneOneAtMostMid(subtrace, cause, value, effect)
  else
    self.checkPatternResponseOneOneExactlyMid(subtrace, cause, value, effect)
  endif
endif

--modified on 17/08/2015
def: checkPatternResponseOneManyPlain(subtrace:OrderedSet(trace::TraceElement), cause:String, effects:Sequence(String)):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(
  elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, i2:Integer) = Tuple{flag:Boolean = true, i2:Integer = 1}
  |
  let e:String = elem.event in
  if e = cause then
    Tuple{flag:Boolean = false, i2:Integer = 1}
  else
    if not iter.flag then
      if e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = true, i2:Integer = 1}
        else
          Tuple{flag:Boolean = iter.flag, i2:Integer = iter.i2 + 1}
        endif
      else
        if e = firstEffect then
          Tuple{flag:Boolean = iter.flag, i2:Integer = 2}
        else
          Tuple{flag:Boolean = iter.flag, i2:Integer = 1}
        endif
      endif
    else
      iter
    endif
  endif
).flag

--modified on 17/08/2015
def: checkPatternResponseOneManyAtLeastMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effects:Sequence(String)):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first() 
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i2:Integer = 1}
  |
  let e:String = elem.event in
  if e = cause then -- latest cause
    Tuple{flag:Boolean = false, midCriticalInstant:Integer = elem.timestamp + distance, i2:Integer = 1}
  else
    if not iter.flag then
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then -- until effects->last(), the property is satisfied so far
          Tuple{flag:Boolean = true, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = iter.i2 + 1}
        endif
      else
        if e = firstEffect and elem.timestamp >= iter.midCriticalInstant then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1}
        endif
      endif
    else
      iter
    endif
  endif
).flag

--modified on 17/08/2015
def: checkPatternResponseOneManyAtMostMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effects:Sequence(String)):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i2:Integer = 1}
  |
  let e:String = elem.event in
  if iter.flag then
    if iter.midCriticalInstant = 0 then
      if e = cause then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + distance, i2:Integer = 1}
      else
        iter
      endif
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = 0, i2:Integer = 1}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = iter.i2 + 1}
        endif
      else
        if e = firstEffect then
          if elem.timestamp <= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2}
          else
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i2:Integer = null}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstant = 0

--modified on 21/01/2016
def: checkPatternResponseOneManyExactlyMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effects:Sequence(String)):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), midCriticalInstant:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = 0, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event in
    if e = cause then
      let ct:Integer = elem.timestamp + distance in
      Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(ct), midCriticalInstant:Integer = ct, i2:Integer = 1}
    else
      if iter.midCriticalInstants->notEmpty() and elem.timestamp >= iter.midCriticalInstant then
        if iter.i2 > 1 and e = effects->at(iter.i2) then
          if iter.i2 = effectSize then
            if iter.midCriticalInstants->size() = 1 then
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1}
            else
              let nextCriticalInstant:Integer = iter.midCriticalInstants->at(2) in
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = nextCriticalInstant, i2:Integer = 1}
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = iter.i2 + 1}
          endif
        else
          if e = firstEffect and elem.timestamp = iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2}
          else
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = null, i2:Integer = null}
          endif
        endif
      else
        iter
      endif
    endif
  else
    iter
  endif
).midCriticalInstants->isEmpty()

--modified on 25/05/2015
def: checkPatternResponseOneManyMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:tempsy::TimeDistance, effects:Sequence(String)):Boolean =
let value:Integer = distance.value, which:tempsy::ComparingOperator = distance.comparingOperator in
if which = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternResponseOneManyAtLeastMid(subtrace, cause, value, effects)
else
  if which = tempsy::ComparingOperator::ATMOST then
    self.checkPatternResponseOneManyAtMostMid(subtrace, cause, value, effects)
  else
    self.checkPatternResponseOneManyExactlyMid(subtrace, cause, value, effects)
  endif
endif

--modified on 17/08/2015
def: checkPatternResponseManyOnePlain(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), effect:String):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, i1:Integer) = Tuple{flag:Boolean = true, i1:Integer = 1}
  |
  let e:String = elem.event in
  if iter.i1 > 1 and e = causes->at(iter.i1) then
    if iter.i1 = causeSize then
      Tuple{flag:Boolean = false, i1:Integer = 1}
    else
      Tuple{flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1}
    endif
  else
    if e = firstCause then
      Tuple{flag:Boolean = iter.flag, i1:Integer = 2}
    else
      if e = effect then
        Tuple{flag:Boolean = true, i1:Integer = 1}
      else
        Tuple{flag:Boolean = iter.flag, i1:Integer = 1}
      endif
    endif
  endif
).flag

-- modified on 17/08/2015
def: checkPatternResponseManyOneAtLeastMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effect:String):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(midCriticalInstant:Integer, i1:Integer) = Tuple{midCriticalInstant:Integer = 0, i1:Integer = 1}
  |
  let e:String = elem.event in
  if iter.i1 > 1 and e = causes->at(iter.i1) then
    if iter.i1 = causeSize then
      Tuple{midCriticalInstant:Integer = elem.timestamp + distance, i1:Integer = 1}
    else
      Tuple{midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1}
    endif
  else
    if e = firstCause then
      Tuple{midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2}
    else
      if e = effect and elem.timestamp >= iter.midCriticalInstant then
        Tuple{midCriticalInstant:Integer = 0, i1:Integer = 1}
      else
        Tuple{midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1}
      endif
    endif
  endif
).midCriticalInstant = 0

-- modified on 17/08/2015
def: checkPatternResponseManyOneAtMostMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effect:String):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1} |
  let e:String = elem.event in
  if iter.flag then
    if iter.midCriticalInstant = 0 then
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + distance, i1:Integer = 1}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1}
        endif
      else
        if e = firstCause then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1}
        endif
      endif
    else
      if e = effect then
        if elem.timestamp <= iter.midCriticalInstant then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = 0, i1:Integer = 1}
        else
          Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null}
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1}
      endif
    endif
  else
    iter
  endif
).midCriticalInstant = 0

-- modified on 21/01/2016
def: checkPatternResponseManyOneExactlyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effect:String):Boolean =
let causeSize:Integer = causes->size(), firstCause:String = causes->first() in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), midCriticalInstant:Integer, i1:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = 0, i1:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event, t:Integer = elem.timestamp in
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        let ct:Integer = t + distance in
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(ct), midCriticalInstant:Integer = ct, i1:Integer = 1}
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1}
      endif
    else
      if e = firstCause then
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2}
      else
        if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
          if t = iter.midCriticalInstant and e = effect then
            if iter.midCriticalInstants->size() = 1 then
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1}
            else
              let nextCriticalInstant:Integer = iter.midCriticalInstants->at(2) in
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = nextCriticalInstant, i1:Integer = 1}
            endif
          else
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = null, i1:Integer = null}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstants->isEmpty()

def: checkPatternResponseManyOneMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:tempsy::TimeDistance, effect:String):Boolean =
let value:Integer = distance.value, which:tempsy::ComparingOperator = distance.comparingOperator in
if which = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternResponseManyOneAtLeastMid(subtrace, causes, value, effect)
else
  if which = tempsy::ComparingOperator::ATMOST then
    self.checkPatternResponseManyOneAtMostMid(subtrace, causes, value, effect)
  else
    self.checkPatternResponseManyOneExactlyMid(subtrace, causes, value, effect)
  endif
endif

-- modified on 17/08/2015
def: checkPatternResponseManyManyPlain(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, i1:Integer, i2:Integer) = Tuple{flag:Boolean = true, i1:Integer = 1, i2:Integer = 1}
  |
  let e:String = elem.event in
  if iter.i2 = effectSize and e = lastEffect then
    Tuple{flag:Boolean = true, i1:Integer = 1, i2:Integer = 1}
  else
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = false, i1:Integer = 1, i2:Integer = 1}
      else
        if iter.i2 > 1 and e = effects->at(iter.i2) then
          Tuple{flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1}
        else
          if not iter.flag and e = firstEffect then
            Tuple{flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, i2:Integer = 2}
          else
            Tuple{flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, i2:Integer = 1}
          endif
        endif
      endif
    else
      if e = firstCause then
        if iter.i2 > 1 and e = effects->at(iter.i2) then
          Tuple{flag:Boolean = iter.flag, i1:Integer = 2, i2:Integer = iter.i2 + 1}
        else
          if not iter.flag and e = firstEffect then
            Tuple{flag:Boolean = iter.flag, i1:Integer = 2, i2:Integer = 2}
          else
            Tuple{flag:Boolean = iter.flag, i1:Integer = 2, i2:Integer = 1}
          endif
        endif
      else
        if iter.i2 > 1 and e = effects->at(iter.i2) then
          Tuple{flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = iter.i2 + 1}
        else
          if not iter.flag and e = firstEffect then
            Tuple{flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = 2}
          else
            Tuple{flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = 1}
          endif
        endif
      endif
    endif
  endif
).flag

-- modified on 17/08/2015
def: checkPatternResponseManyManyAtLeastMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1}
  |
  let e:String = elem.event in
  if iter.i2 = effectSize and e = lastEffect then
    Tuple{flag:Boolean = true, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1}
  else
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = false, midCriticalInstant:Integer = elem.timestamp + distance, i1:Integer = 1, i2:Integer = 1}
      else
        if iter.i2 > 1 and e = effects->at(iter.i2) then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1}
        else
          if not iter.flag and e = firstEffect and elem.timestamp >= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1}
          endif
        endif
      endif
    else
      if e = firstCause then
        if iter.i2 > 1 and e = effects->at(iter.i2) then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = iter.i2 + 1}
        else
          if not iter.flag and e = firstEffect and elem.timestamp >= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 2}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 1}
          endif
        endif
      else
        if iter.i2 > 1 and e = effects->at(iter.i2) then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = iter.i2 + 1}
        else
          if not iter.flag and e = firstEffect and elem.timestamp >= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1}
          endif
        endif
      endif
    endif
  endif
).flag

-- modified on 17/08/2015
def: checkPatternResponseManyManyAtMostMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1}
  |
  let e:String = elem.event in
  if iter.flag then
    if iter.midCriticalInstant = 0 then
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + distance, i1:Integer = 1, i2:Integer = iter.i2}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2}
        endif
      else
        if e = firstCause then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = iter.i2}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = iter.i2}
        endif
      endif
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = 0, i1:Integer = iter.i1, i2:Integer = 1}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1, i2:Integer = iter.i2 + 1}
        endif
      else
        if e = firstEffect then
          if elem.timestamp <= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1, i2:Integer = 2}
          else
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, i2:Integer = null}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1, i2:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstant = 0

-- modified on 21/01/2016
def: checkPatternResponseManyManyExactlyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), midCriticalInstant:Integer, i1:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1} |
  if iter.flag then
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      if iter.midCriticalInstants->size() = 1 then
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1}
      else
        let nextCriticalInstant:Integer = iter.midCriticalInstants->at(2) in
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = nextCriticalInstant, i1:Integer = 1, i2:Integer = 1}
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          let ct:Integer = elem.timestamp + distance in
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(ct), midCriticalInstant:Integer = ct, i1:Integer = 1, i2:Integer = 1}
        else
          if iter.midCriticalInstants->notEmpty() and elem.timestamp >= iter.midCriticalInstant then
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1}
            else
              if e = firstEffect and elem.timestamp = iter.midCriticalInstant then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2}
              else
                Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = null, i1:Integer = null, i2:Integer = null}
              endif
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1}
          endif
        endif
      else
        if e = firstCause then
          if iter.midCriticalInstants->notEmpty() and elem.timestamp >= iter.midCriticalInstant then
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = iter.i2 + 1}
            else
              if e = firstEffect and elem.timestamp = iter.midCriticalInstant then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 2}
              else
                Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = null, i1:Integer = null, i2:Integer = null}
              endif
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 1}
          endif
        else
          if iter.midCriticalInstants->notEmpty() and elem.timestamp >= iter.midCriticalInstant then
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = iter.i2 + 1}
            else
              if e = firstEffect and elem.timestamp = iter.midCriticalInstant then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2}
              else
                Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = null, i1:Integer = null, i2:Integer = null}
              endif
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1}
          endif
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstants->isEmpty()

-- modified on 28/05/2015
def: checkPatternResponseManyManyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:tempsy::TimeDistance, effects:Sequence(String)):Boolean =
let value:Integer = distance.value, which:tempsy::ComparingOperator = distance.comparingOperator in
if which = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternResponseManyManyAtLeastMid(subtrace, causes, value, effects)
else
  if which = tempsy::ComparingOperator::ATMOST then
    self.checkPatternResponseManyManyAtMostMid(subtrace, causes, value, effects)
  else
    self.checkPatternResponseManyManyExactlyMid(subtrace, causes, value, effects)
  endif
endif

-- modified on 18/08/2015
def: checkPatternResponseOneManyRight(subtrace:OrderedSet(trace::TraceElement), cause:String, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(
  elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, i2:Integer, effectCriticalInstant:Integer) = Tuple{flag:Boolean = true, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  let e:String = elem.event in
  if e = cause then
    Tuple{flag:Boolean = false, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
  else
    if not iter.flag then
      let t:Integer = elem.timestamp in
      if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = true, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          let i:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
        endif
      else
        if e = firstEffect then
          Tuple{flag:Boolean = iter.flag, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
        else
          Tuple{flag:Boolean = iter.flag, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    else
      iter
    endif
  endif
).flag

-- modified on 18/08/2015
def: checkPatternResponseManyManyRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, i1:Integer, i2:Integer, effectCriticalInstant:Integer) = Tuple{flag:Boolean = true, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  let e:String = elem.event in
  if iter.i2 = effectSize and e = lastEffect and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->last().which) then
    Tuple{flag:Boolean = true, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
  else
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = false, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        let t:Integer = elem.timestamp in
        if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          let i:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
        else
          if not iter.flag and e = firstEffect then
            Tuple{flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
      endif
    else
      if e = firstCause then
        let t:Integer = elem.timestamp in
        if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          let i:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, i1:Integer = 2, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
        else
          if not iter.flag and e = firstEffect then
            Tuple{flag:Boolean = iter.flag, i1:Integer = 2, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = iter.flag, i1:Integer = 2, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
      else
        let t:Integer = elem.timestamp in
        if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          let i:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
        else
          if not iter.flag and e = firstEffect then
            Tuple{flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
      endif
    endif
  endif
).flag

--modified on 18/08/2015
def: checkPatternResponseOneManyAtLeastMidRight(subtrace:OrderedSet(trace::TraceElement), cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer) = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  let e:String = elem.event in
  if e = cause then -- latest cause
    Tuple{flag:Boolean = false, midCriticalInstant:Integer = elem.timestamp + midDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
  else
    if not iter.flag then
      let t:Integer = elem.timestamp in
      if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = true, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          let i:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
        endif
      else
        if e = firstEffect and t >= iter.midCriticalInstant then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    else
      iter
    endif
  endif
).flag

--modified on 18/08/2015
def: checkPatternResponseOneManyAtMostMidRight(subtrace:OrderedSet(trace::TraceElement), cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  let e:String = elem.event in
  if iter.flag then
    if iter.midCriticalInstant = 0 then
      if e = cause then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + midDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        iter
      endif
    else
      let t:Integer = elem.timestamp in
      if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          let i:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
        endif
      else
        if e = firstEffect then
          if t <= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i2:Integer = null, effectCriticalInstant:Integer = null}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstant = 0

--modified on 21/01/2016
def: checkPatternResponseOneManyExactlyMidRight(subtrace:OrderedSet(trace::TraceElement), cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), midCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if e = cause then
      let ct:Integer = elem.timestamp + midDistance in
      Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(ct), midCriticalInstant:Integer = ct, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
    else
      let t:Integer = elem.timestamp in
      if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
        if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          if iter.i2 = effectSize then
            if iter.midCriticalInstants->size() = 1 then
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            else
              let nextCriticalInstant:Integer = iter.midCriticalInstants->at(2) in
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = nextCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          else
            let i:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
          endif
        else
          if e = firstEffect and t = iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          endif
        endif
      else
        iter
      endif
    endif
  else
    iter
  endif
).midCriticalInstants->isEmpty()

--modified on 10/06/2015
def: checkPatternResponseOneManyMidRight(subtrace:OrderedSet(trace::TraceElement), cause:String, midDistance:tempsy::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator = midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternResponseOneManyAtLeastMidRight(subtrace, cause, midValue, effects, effectDistances)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.checkPatternResponseOneManyAtMostMidRight(subtrace, cause, midValue, effects, effectDistances)
  else
    self.checkPatternResponseOneManyExactlyMidRight(subtrace, cause, midValue, effects, effectDistances)
  endif
endif

-- modified on 18/08/2015
def: checkPatternResponseManyManyAtLeastMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  let e:String = elem.event in
  if iter.i2 = effectSize and e = lastEffect and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->last().which) then
    Tuple{flag:Boolean = true, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
  else
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = false, midCriticalInstant:Integer = elem.timestamp + midDistance, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        let t:Integer = elem.timestamp in
        if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          let i:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
        else
          if not iter.flag and e = firstEffect and t >= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
      endif
    else
      if e = firstCause then
        let t:Integer = elem.timestamp in
        if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          let i:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
        else
          if not iter.flag and e = firstEffect and t >= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
      else
        let t:Integer = elem.timestamp in
        if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          let i:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
        else
          if not iter.flag and e = firstEffect and t >= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
      endif
    endif
  endif
).flag

-- modified on 18/08/2015
def: checkPatternResponseManyManyAtMostMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  let e:String = elem.event in
  if iter.flag then
    if iter.midCriticalInstant = 0 then
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + midDistance, i1:Integer = 1, i2:Integer = iter.i2, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      else
        if e = firstCause then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = iter.i2, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = iter.i2, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    else
      let t:Integer = elem.timestamp in
      if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = 0, i1:Integer = iter.i1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          let i:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
        endif
      else
        if e = firstEffect then
          if t <= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstant = 0

-- modified on 21/01/2016
def: checkPatternResponseManyManyExactlyMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), midCriticalInstant:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event, t:Integer = elem.timestamp in
    if iter.i2 = effectSize and e = lastEffect then
      if iter.midCriticalInstants->size() = 1 then
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        let nextCriticalInstant:Integer = iter.midCriticalInstants->at(2) in
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = nextCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          let ct:Integer = t + midDistance in
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(ct), midCriticalInstant:Integer = ct, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
            if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              let i:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
            else
              if e = firstEffect and t = iter.midCriticalInstant then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
              else
                Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = null, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
              endif
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
      else
        if e = firstCause then
          if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
            if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              let i:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
            else
              if e = firstEffect and t = iter.midCriticalInstant then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
              else
                Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = null, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
              endif
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        else
          if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
            if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              let i:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
            else
              if e = firstEffect and t = iter.midCriticalInstant then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
              else
                Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = null, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
              endif
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstants->isEmpty()

-- modified on 10/06/2015
def: checkPatternResponseManyManyMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), midDistance:tempsy::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator = midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternResponseManyManyAtLeastMidRight(subtrace, causes, midValue, effects, effectDistances)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.checkPatternResponseManyManyAtMostMidRight(subtrace, causes, midValue, effects, effectDistances)
  else
    self.checkPatternResponseManyManyExactlyMidRight(subtrace, causes, midValue, effects, effectDistances)
  endif
endif

-- modified on 18/08/2015
def: checkPatternResponseManyOneLeft(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effect:String):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, i1:Integer, causeCriticalInstant:Integer) = Tuple{flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = 0}
  |
  let e:String = elem.event in
  if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
    if iter.i1 = causeSize then
      Tuple{flag:Boolean = false, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
    else
      let i:Integer = iter.i1 + 1 in
      Tuple{flag:Boolean = iter.flag, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i).value}
    endif
  else
    if e = firstCause then
      Tuple{flag:Boolean = iter.flag, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance}
    else
      if e = effect then
        Tuple{flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      else
        Tuple{flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      endif
    endif
  endif
).flag

-- modified on 18/08/2015
def: checkPatternResponseManyManyLeft(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer) = Tuple{flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1}
  |
  let e:String = elem.event in
  if iter.i2 = effectSize and e = lastEffect then
    Tuple{flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
  else
    if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = false, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
      else
        let i:Integer = iter.i1 + 1 in
        if iter.i2 > 1 and e = effects->at(iter.i2) then
          Tuple{flag:Boolean = iter.flag, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i).value, i2:Integer = iter.i2 + 1}
        else
          if not iter.flag and e = firstEffect then
            Tuple{flag:Boolean = iter.flag, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i).value, i2:Integer = 2}
          else
            Tuple{flag:Boolean = iter.flag, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i).value, i2:Integer = 1}
          endif
        endif
      endif
    else
      if e = firstCause then
        if iter.i2 > 1 and e = effects->at(iter.i2) then
          Tuple{flag:Boolean = iter.flag, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = iter.i2 + 1}
        else
          if not iter.flag and e = firstEffect then
            Tuple{flag:Boolean = iter.flag, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 2}
          else
            Tuple{flag:Boolean = iter.flag, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1}
          endif
        endif
      else
        if iter.i2 > 1 and e = effects->at(iter.i2) then
          Tuple{flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1}
        else
          if not iter.flag and e = firstEffect then
            Tuple{flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2}
          else
            Tuple{flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
          endif
        endif
      endif
    endif
  endif
).flag

-- modified on 18/08/2015
def: checkPatternResponseManyOneLeftAtLeastMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer) = Tuple{midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0}
  |
  let e:String = elem.event, t:Integer = elem.timestamp in
  if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(t, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
    if iter.i1 = causeSize then
      Tuple{midCriticalInstant:Integer = t + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
    else
      let i:Integer = iter.i1 + 1 in
      Tuple{midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = t + causeDistances->at(i).value}
    endif
  else
    if e = firstCause then
      Tuple{midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance}
    else
      if e = effect and t >= iter.midCriticalInstant then
        Tuple{midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      else
        Tuple{midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      endif
    endif
  endif
).midCriticalInstant = 0

-- modified on 18/08/2015
def: checkPatternResponseManyOneLeftAtMostMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0}
  |
  let e:String = elem.event in
  if iter.flag then
    if iter.midCriticalInstant = 0 then
      let t:Integer = elem.timestamp in
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(t, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = t + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
        else
          let i:Integer = iter.i1 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = t + causeDistances->at(i).value}
        endif
      else
        if e = firstCause then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
        endif
      endif
    else
      if e = effect then
        if elem.timestamp <= iter.midCriticalInstant then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
        else
          Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null}
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      endif
    endif
  else
    iter
  endif
).midCriticalInstant = 0

-- modified on 21/01/2016
def: checkPatternResponseManyOneLeftExactlyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event, t:Integer = elem.timestamp in
    if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(t, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        let ct:Integer = t + midDistance in
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(ct), midCriticalInstant:Integer = ct, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      else
        let i:Integer = iter.i1 + 1 in
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = t + causeDistances->at(i).value}
      endif
    else
      if e = firstCause then
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance}
      else
        if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
          if t = iter.midCriticalInstant and e = effect then
            if iter.midCriticalInstants->size() = 1 then
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
            else
              let nextCriticalInstant:Integer = iter.midCriticalInstants->at(2) in
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = nextCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
            endif
          else
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstants->isEmpty()

-- modified on 10/06/2015
def: checkPatternResponseManyOneLeftMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:tempsy::TimeDistance, effect:String):Boolean =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator = midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternResponseManyOneLeftAtLeastMid(subtrace, causes, causeDistances, midValue, effect)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.checkPatternResponseManyOneLeftAtMostMid(subtrace, causes, causeDistances, midValue, effect)
  else
    self.checkPatternResponseManyOneLeftExactlyMid(subtrace, causes, causeDistances, midValue, effect)
  endif
endif

-- modified on 18/08/2015
def: checkPatternResponseManyManyLeftAtLeastMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1}
  |
  let e:String = elem.event in
  if iter.i2 = effectSize and e = lastEffect then
    Tuple{flag:Boolean = true, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
  else
    if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = false, midCriticalInstant:Integer = elem.timestamp + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
      else
        let i:Integer = iter.i1 + 1 in
        if iter.i2 > 1 and e = effects->at(iter.i2) then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i).value, i2:Integer = iter.i2 + 1}
        else
          if not iter.flag and e = firstEffect and elem.timestamp >= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i).value, i2:Integer = 2}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i).value, i2:Integer = 1}
          endif
        endif
      endif
    else
      if e = firstCause then
        if iter.i2 > 1 and e = effects->at(iter.i2) then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = iter.i2 + 1}
        else
          if not iter.flag and e = firstEffect and elem.timestamp >= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 2}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1}
          endif
        endif
      else
        if iter.i2 > 1 and e = effects->at(iter.i2) then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1}
        else
          if not iter.flag and e = firstEffect and elem.timestamp >= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
          endif
        endif
      endif
    endif
  endif
).flag

-- modified on 18/08/2015
def: checkPatternResponseManyManyLeftAtMostMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1} |
  let e:String = elem.event in
  if iter.flag then
    if iter.midCriticalInstant = 0 then
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2}
        else
          let i:Integer = iter.i1 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i).value, i2:Integer = iter.i2}
        endif
      else
        if e = firstCause then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = iter.i2}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2}
        endif
      endif
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = 0, i1:Integer = iter.i1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1}
        endif
      else
        if e = firstEffect then
          if elem.timestamp <= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2}
          else
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
          endif          
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstant = 0

-- modified on 21/01/2016
def: checkPatternResponseManyManyLeftExactlyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1} |
  if iter.flag then
    let e:String = elem.event, t:Integer = elem.timestamp in
    if iter.i2 = effectSize and e = lastEffect then
      if iter.midCriticalInstants->size() = 1 then
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
      else
        let nextCriticalInstant:Integer = iter.midCriticalInstants->at(2) in
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = nextCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(t, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          let ct:Integer = t + midDistance in
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(ct), midCriticalInstant:Integer = ct, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
        else
          let i:Integer = iter.i1 + 1 in
          if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i).value, i2:Integer = iter.i2 + 1}
            else
              if e = firstEffect and t = iter.midCriticalInstant then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i).value, i2:Integer = 2}
              else
                Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
              endif
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i).value, i2:Integer = 1}
          endif
        endif
      else
        if e = firstCause then
          if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = iter.i2 + 1}
            else
              if e = firstEffect and t = iter.midCriticalInstant then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 2}
              else
                Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
              endif
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1}
          endif
        else
          if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
            if iter.i2 > 1 and e = effects->at(iter.i2) then
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1}
            else
              if e = firstEffect and t = iter.midCriticalInstant then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2}
              else
                Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
              endif
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
          endif
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstants->isEmpty()

-- modified on 10/06/2015
def: checkPatternResponseManyManyLeftMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:tempsy::TimeDistance, effects:Sequence(String)):Boolean =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator = midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternResponseManyManyLeftAtLeastMid(subtrace, causes, causeDistances, midValue, effects)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.checkPatternResponseManyManyLeftAtMostMid(subtrace, causes, causeDistances, midValue, effects)
  else
    self.checkPatternResponseManyManyLeftExactlyMid(subtrace, causes, causeDistances, midValue, effects)
  endif
endif

-- modified on 18/08/2015
def: checkPatternResponseManyManyLeftRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer) = Tuple{flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  let e:String = elem.event in
  if iter.i2 = effectSize and e = lastEffect and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->last().which) then
    Tuple{flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
  else
    if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = false, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        let t:Integer = elem.timestamp, i11:Integer = iter.i1 + 1 in
        if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          let i22:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value}
        else
          if not iter.flag and e = firstEffect then
            Tuple{flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
      endif
    else
      if e = firstCause then
        let t:Integer = elem.timestamp in
        if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          let i22:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value}
        else
          if not iter.flag and e = firstEffect then
            Tuple{flag:Boolean = iter.flag, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = iter.flag, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
      else
        let t:Integer = elem.timestamp in
        if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          let i22:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value}
        else
          if not iter.flag and e = firstEffect then
            Tuple{flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
      endif
    endif
  endif
).flag


-- modified on 18/08/2015
def: checkPatternResponseManyManyLeftAtLeastMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  let e:String = elem.event in
  if iter.i2 = effectSize and e = lastEffect and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->last().which) then
    Tuple{flag:Boolean = true, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
  else
    if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = false, midCriticalInstant:Integer = elem.timestamp + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        let t:Integer = elem.timestamp, i11:Integer = iter.i1 + 1 in
        if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          let i22:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = t + causeDistances->at(i22).value}
        else
          if not iter.flag and e = firstEffect and t >= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
      endif
    else
      if e = firstCause then
        let t:Integer = elem.timestamp in
        if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          let i22:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + causeDistances->at(i22).value}
        else
          if not iter.flag and e = firstEffect and t >= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = t + secondCauseDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
      else
        let t:Integer = elem.timestamp in
        if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          let i22:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + causeDistances->at(i22).value}
        else
          if not iter.flag and e = firstEffect and t >= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
      endif
    endif
  endif
).flag

-- modified on 18/08/2015
def: checkPatternResponseManyManyLeftAtMostMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  let e:String = elem.event in
  if iter.flag then
    if iter.midCriticalInstant = 0 then
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          let i11:Integer = iter.i1 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = iter.i2, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      else
        if e = firstCause then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = iter.i2, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    else
      let t:Integer = elem.timestamp in
      if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = 0, i1:Integer = iter.i1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          let i22:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = t + effectDistances->at(i22).value}
        endif
      else
        if e = firstEffect then
          if t <= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + effectDistances->at(2).value}
          else
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstant = 0

-- modified on 21/01/2016
def: checkPatternResponseManyManyLeftExactlyMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event, t:Integer = elem.timestamp in
    if iter.i2 = effectSize and e = lastEffect then
      if iter.midCriticalInstants->size() = 1 then
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        let nextCriticalInstant:Integer = iter.midCriticalInstants->at(2) in
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = nextCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(t, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          let ct:Integer = t + midDistance in
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(ct), midCriticalInstant:Integer = ct, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          let i11:Integer = iter.i1 + 1 in
          if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
            if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = t + effectDistances->at(i22).value}
            else
              if e = firstEffect and t = iter.midCriticalInstant then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
              else
                Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
              endif
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
      else
        if e = firstCause then
          if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
            if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = i22, effectCriticalInstant:Integer = t + effectDistances->at(i22).value}
            else
              if e = firstEffect and t = iter.midCriticalInstant then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
              else
                Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
              endif
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        else
          if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
            if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = t + effectDistances->at(i22).value}
            else
              if e = firstEffect and t = iter.midCriticalInstant then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
              else
                Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
              endif
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstants->isEmpty()

-- modified on 10/06/2015
def: checkPatternResponseManyManyLeftMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:tempsy::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator = midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternResponseManyManyLeftAtLeastMidRight(subtrace, causes, causeDistances, midValue, effects, effectDistances)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.checkPatternResponseManyManyLeftAtMostMidRight(subtrace, causes, causeDistances, midValue, effects, effectDistances)
  else
    self.checkPatternResponseManyManyLeftExactlyMidRight(subtrace, causes, causeDistances, midValue, effects, effectDistances)
  endif
endif

def: checkPatternResponse(subtrace:OrderedSet(trace::TraceElement), pattern:tempsy::Pattern):Boolean =
--check the satisfiability of the response pattern 'effect responding cause'
--in the first event in the chain 'effect', it may contains time distance to the last event in the chain 'cause'
if subtrace->isEmpty() then
  true
else
  let orderPattern:tempsy::OrderPattern = pattern.oclAsType(tempsy::OrderPattern),
      causes:Sequence(String) = orderPattern.block2.event.name,
      causeDistances:Sequence(Tuple(which:Integer, value:Integer)) = self.loadDistances(orderPattern.block2.timeDistance),
      causeSize:Integer = causes->size(),
      effects:Sequence(String) = orderPattern.block1.event.name,
      effectDistances:Sequence(Tuple(which:Integer, value:Integer)) = self.loadDistances(orderPattern.block1.timeDistance),
      effectSize:Integer = effects->size()
  in
  if causeDistances->isEmpty() then
    if effectDistances->isEmpty() then
      if orderPattern.timeDistance->isEmpty() then
        if causeSize = 1 then
          let cause:String = causes->first() in
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.checkPatternResponseOneOnePlain(subtrace, cause, effect)
          else
            self.checkPatternResponseOneManyPlain(subtrace, cause, effects)
          endif
        else
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.checkPatternResponseManyOnePlain(subtrace, causes, effect)
          else
            self.checkPatternResponseManyManyPlain(subtrace, causes, effects)
          endif
        endif
      else
        if causeSize = 1 then
          let cause:String = causes->first() in
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.checkPatternResponseOneOneMid(subtrace, cause, orderPattern.timeDistance, effect)
          else
            self.checkPatternResponseOneManyMid(subtrace, cause, orderPattern.timeDistance, effects)
          endif
        else
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.checkPatternResponseManyOneMid(subtrace, causes, orderPattern.timeDistance, effect)
          else
            self.checkPatternResponseManyManyMid(subtrace, causes, orderPattern.timeDistance, effects)
          endif
        endif
      endif
    else
      if orderPattern.timeDistance->isEmpty() then
        if causeSize = 1 then
          let cause:String = causes->first() in
          self.checkPatternResponseOneManyRight(subtrace, cause, effects, effectDistances)
        else
          self.checkPatternResponseManyManyRight(subtrace, causes, effects, effectDistances)
        endif
      else
        if causeSize = 1 then
          let cause:String = causes->first() in
          self.checkPatternResponseOneManyMidRight(subtrace, cause, orderPattern.timeDistance, effects, effectDistances)
        else
          self.checkPatternResponseManyManyMidRight(subtrace, causes, orderPattern.timeDistance, effects, effectDistances)
        endif
      endif
    endif
  else
    if effectDistances->isEmpty() then
      if orderPattern.timeDistance->isEmpty() then
        if effectSize = 1 then
          let effect:String = effects->first() in
          self.checkPatternResponseManyOneLeft(subtrace, causes, causeDistances, effect)
        else
          self.checkPatternResponseManyManyLeft(subtrace, causes, causeDistances, effects)
        endif
      else
        if effectSize = 1 then
          let effect:String = effects->first() in
          self.checkPatternResponseManyOneLeftMid(subtrace, causes, causeDistances, orderPattern.timeDistance, effect)
        else
          self.checkPatternResponseManyManyLeftMid(subtrace, causes, causeDistances, orderPattern.timeDistance, effects)
        endif
      endif
    else
      if orderPattern.timeDistance->isEmpty() then
        self.checkPatternResponseManyManyLeftRight(subtrace, causes, causeDistances, effects, effectDistances)
      else
        self.checkPatternResponseManyManyLeftMidRight(subtrace, causes, causeDistances, orderPattern.timeDistance, effects, effectDistances)
      endif
    endif
  endif
endif

--modified on 11/06/2015
def: checkPatternPrecedenceOneOnePlain(subtrace:OrderedSet(trace::TraceElement), cause:String, effect:String):Boolean =
--"cause preceding effect"
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, result:Integer) = Tuple{flag:Boolean = true, result:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if e = cause then
      Tuple{flag:Boolean = false, result:Integer = -1}
    else
      if e = effect then
        Tuple{flag:Boolean = false, result:Integer = -2} -- violation
      else
        iter
      endif
    endif
  else
    iter
  endif
).result >= -1

-- modified on 11/06/2015
def: checkPatternPrecedenceOneOneAtLeastMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effect:String):Boolean =
--"cause preceding at least distance tu effect"
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, midCriticalInstant:Integer) = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.midCriticalInstant = 0 and e = cause then --catch the first occurrence of cause
      Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + distance}
    else
      if e = effect then
        if iter.midCriticalInstant = 0 or elem.timestamp < iter.midCriticalInstant then
          Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2} -- violation
        else
          Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1}
        endif
      else
        iter
      endif
    endif
  else
    iter
  endif
).midCriticalInstant >= -1

-- modified on 11/06/2015
def: checkPatternPrecedenceOneOneAtMostMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effect:String):Boolean =
--"cause preceding at most distance tu effect"
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, midCriticalInstant:Integer) = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if e = cause then --latest cause
      Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + distance}
    else
      if e = effect and elem.timestamp > iter.midCriticalInstant then
        Tuple{flag:Boolean = false, midCriticalInstant:Integer = null} -- violation
      else
        iter
      endif
    endif
  else
    iter
  endif
).flag

-- modified on 21/04/2015
def: checkPatternPrecedenceOneOneExactlyMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effect:String):Boolean =
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer)) = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}} |
  if iter.flag then
    let e:String = elem.event in
    if e = cause then
      Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(elem.timestamp+distance)}
    else
      if e = effect then
        let t:Integer = elem.timestamp in
        if iter.midCriticalInstants->includes(t) then
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t)}
        else
          Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null}
        endif
      else
        iter
      endif
    endif
  else
    iter
  endif
).flag

-- modified on 15/04/2015
def: checkPatternPrecedenceOneOneMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:tempsy::TimeDistance, effect:String):Boolean =
let value:Integer = distance.value, which:tempsy::ComparingOperator = distance.comparingOperator in
if which = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceOneOneAtLeastMid(subtrace, cause, value, effect)
else
  if which = tempsy::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceOneOneAtMostMid(subtrace, cause, value, effect)
  else
    self.checkPatternPrecedenceOneOneExactlyMid(subtrace, cause, value, effect)
  endif
endif

-- modified on 18/08/2015
def: checkPatternPrecedenceOneManyPlain(subtrace:OrderedSet(trace::TraceElement), cause:String, effects:Sequence(String)):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, result:Integer, i2:Integer) = Tuple{flag:Boolean = true, result:Integer = 0, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event in
    if e = cause then --catch the first occurrence of cause
      Tuple{flag:Boolean = false, result:Integer = -1, i2:Integer = null}
    else
      if e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = false, result:Integer = -2, i2:Integer = null}
        else
          Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i2:Integer = iter.i2 + 1}
        endif
      else
        if e = firstEffect then
          Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i2:Integer = 2}
        else
          Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i2:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).result >= -1

-- modified on 18/08/2015
def: checkPatternPrecedenceOneManyAtLeastMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effects:Sequence(String)):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i2:Integer) = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.midCriticalInstant = 0 and e = cause then --catch the first occurrence of cause
      Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + distance, i2:Integer = 1}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2, i2:Integer = null}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = iter.i2 + 1}
        endif
      else
        if e = firstEffect then
          if iter.midCriticalInstant = 0 or elem.timestamp < iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2}
          else
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i2:Integer = null}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstant >= -1

-- modified on 18/08/2015
def: checkPatternPrecedenceOneManyAtMostMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effects:Sequence(String)):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i2:Integer) = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i2:Integer = 1} |
  let e:String = elem.event in
  if iter.flag then
    if e = cause then
      Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + distance, i2:Integer = 1}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = false, midCriticalInstant:Integer = null, i2:Integer = null}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = iter.i2 + 1}
        endif
      else
        if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).flag

-- modified on 18/08/2015
def: checkPatternPrecedenceOneManyExactlyMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effects:Sequence(String)):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), i2:Integer) = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event in
    if e = cause then
      Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(elem.timestamp+distance), i2:Integer = 1}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null, i2:Integer = null}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i2:Integer = iter.i2 + 1}
        endif
      else
        if e = firstEffect then
          let t:Integer = elem.timestamp in
          if iter.midCriticalInstants->includes(t) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i2:Integer = 1}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i2:Integer = 2}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i2:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).flag

-- modified on 22/04/2015
def: checkPatternPrecedenceOneManyMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:tempsy::TimeDistance, effects:Sequence(String)):Boolean =
let value:Integer = distance.value, which:tempsy::ComparingOperator = distance.comparingOperator in
if which = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceOneManyAtLeastMid(subtrace, cause, value, effects)
else
  if which = tempsy::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceOneManyAtMostMid(subtrace, cause, value, effects)
  else
    self.checkPatternPrecedenceOneManyExactlyMid(subtrace, cause, value, effects)
  endif
endif


--modified on 18/08/2015
def: checkPatternPrecedenceOneManyRight(subtrace:OrderedSet(trace::TraceElement), cause:String, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, result:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, result:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if e = cause then
      Tuple{flag:Boolean = false, result:Integer = -1, i2:Integer = null, effectCriticalInstant:Integer = null}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = false, result:Integer = -2, i2:Integer = null, effectCriticalInstant:Integer = null}
        else
          let i22:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
        endif
      else
        if e = firstEffect then
          Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
        else
          Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    endif
  else
    iter
  endif
).result >= -1

--modified on 18/08/2015
def: checkPatternPrecedenceOneManyAtLeastMidRight(subtrace:OrderedSet(trace::TraceElement), cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.midCriticalInstant = 0 and e = cause then --catch the first occurrence of cause
      Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + midDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2, i2:Integer = null, effectCriticalInstant:Integer = null}
        else
          let i22:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
        endif
      else
        if e = firstEffect then
          if iter.midCriticalInstant = 0 or elem.timestamp < iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
          else
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i2:Integer = null, effectCriticalInstant:Integer = null}
          endif  
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstant >= -1

--modified on 18/08/2015
def: checkPatternPrecedenceOneManyAtMostMidRight(subtrace:OrderedSet(trace::TraceElement), cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if e = cause then
      Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + midDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = false, midCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
        else
          let i22:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
        endif
      else
        if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    endif
  else
    iter
  endif
).flag

-- added on 18/08/2015
def: checkPatternPrecedenceOneManyExactlyMidRight(subtrace:OrderedSet(trace::TraceElement), cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if e = cause then
      Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(elem.timestamp+midDistance), i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
    else
      if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null, i2:Integer = null, effectCriticalInstant:Integer = null}
        else
          let i22:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
        endif
      else
        if e = firstEffect then
          let t:Integer = elem.timestamp in
          if iter.midCriticalInstants->includes(t) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    endif
  else
    iter
  endif
).flag

-- modified on 22/04/2015
def: checkPatternPrecedenceOneManyMidRight(subtrace:OrderedSet(trace::TraceElement), cause:String, midDistance:tempsy::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator=midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceOneManyAtLeastMidRight(subtrace, cause, midValue, effects, effectDistances)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceOneManyAtMostMidRight(subtrace, cause, midValue, effects, effectDistances)
  else
    self.checkPatternPrecedenceOneManyExactlyMidRight(subtrace, cause, midValue, effects, effectDistances)
  endif
endif

-- modified on 18/08/2015
def: checkPatternPrecedenceManyOnePlain(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), effect:String):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first()
in
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, result:Integer, i1:Integer) = Tuple{flag:Boolean = true, result:Integer = 0, i1:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = false, result:Integer = -1, i1:Integer = null}
      else
        Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = iter.i1 + 1}
      endif
    else
      if e = firstCause then
        Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 2}
      else
        if e = effect then
          Tuple{flag:Boolean = false, result:Integer = -2, i1:Integer = null}
        else
          Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).result >= -1

--modified on 18/08/2015
def: checkPatternPrecedenceManyOneAtLeastMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effect:String):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer) = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + distance, i1:Integer = 1}
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1}
      endif
    else
      if iter.midCriticalInstant = 0 and e = firstCause then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2}
      else
        if e = effect then
          if iter.midCriticalInstant = 0 or elem.timestamp < iter.midCriticalInstant then
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2, i1:Integer = null}
          else
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstant >= -1

--modified on 18/08/2015
def: checkPatternPrecedenceManyOneAtMostMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effect:String):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer) = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + distance, i1:Integer = 1}
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1}
      endif
    else
      if e = firstCause then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2}
      else
        if e = effect and elem.timestamp > iter.midCriticalInstant then
          Tuple{flag:Boolean = false, midCriticalInstant:Integer = null, i1:Integer = null}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).flag

--modified on 18/08/2015
def: checkPatternPrecedenceManyOneExactlyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effect:String):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), i1:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, i1:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(elem.timestamp+distance), i1:Integer = 1}
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = iter.i1 + 1}
      endif
    else
      if e = firstCause then
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 2}
      else
        if e = effect then
          let t:Integer = elem.timestamp in
          if iter.midCriticalInstants->includes(t) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 1}
          else
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null, i1:Integer = null}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).flag

-- modified on 11/06/2015
def: checkPatternPrecedenceManyOneMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:tempsy::TimeDistance, effect:String):Boolean =
let value:Integer = distance.value, which:tempsy::ComparingOperator=distance.comparingOperator in
if which = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceManyOneAtLeastMid(subtrace, causes, value, effect)
else
  if which = tempsy::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceManyOneAtMostMid(subtrace, causes, value, effect)
  else
    self.checkPatternPrecedenceManyOneExactlyMid(subtrace, causes, value, effect)
  endif
endif

-- modified on 18/08/2015
def: checkPatternPrecedenceManyOneLeft(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effect:String):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, result:Integer, i1:Integer, causeCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, result:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = false, result:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null}
      else
        let i11:Integer = iter.i1 + 1 in
        Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value}
      endif
    else
      if e = firstCause then
        Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance}
      else
        if e = effect then
          Tuple{flag:Boolean = false, result:Integer = -2, i1:Integer = null, causeCriticalInstant:Integer = null}
        else
          Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
        endif
      endif
    endif
  else
    iter
  endif
).result >= -1

--modified on 18/08/2015
def: checkPatternPrecedenceManyOneLeftAtLeastMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then--imply iter.midCriticalInstant = 0
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      else
        let i11:Integer = iter.i1 + 1 in
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value}
      endif
    else
      if iter.midCriticalInstant = 0 and e = firstCause then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance}
      else
        if e = effect then
          if iter.midCriticalInstant = 0 or elem.timestamp < iter.midCriticalInstant then
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2, i1:Integer = null, causeCriticalInstant:Integer = null}
          else
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstant >= -1

--modified on 18/08/2015
def: checkPatternPrecedenceManyOneLeftAtMostMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      else
        let i11:Integer = iter.i1 + 1 in
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value}
      endif
    else
      if e = firstCause then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance}
      else
        if e = effect and elem.timestamp > iter.midCriticalInstant then
          Tuple{flag:Boolean = false, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
        endif
      endif
    endif
  else
    iter
  endif
).flag

--modified on 18/08/2015
def: checkPatternPrecedenceManyOneLeftExactlyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), i1:Integer, causeCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, i1:Integer = 1, causeCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(elem.timestamp+midDistance), i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      else
        let i11:Integer = iter.i1 + 1 in
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value}
      endif
    else
      if e = firstCause then
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance}
      else
        if e = effect then
          let t:Integer = elem.timestamp in
          if iter.midCriticalInstants->includes(t) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
          else
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null, i1:Integer = null, causeCriticalInstant:Integer = null}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
        endif
      endif
    endif
  else
    iter
  endif
).flag

-- modified on 11/06/2015
def: checkPatternPrecedenceManyOneLeftMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:tempsy::TimeDistance, effect:String):Boolean =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator=midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceManyOneLeftAtLeastMid(subtrace, causes, causeDistances, midValue, effect)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceManyOneLeftAtMostMid(subtrace, causes, causeDistances, midValue, effect)
  else
    self.checkPatternPrecedenceManyOneLeftExactlyMid(subtrace, causes, causeDistances, midValue, effect)
  endif
endif

--modified on 18/08/2015
def: checkPatternPrecedenceManyManyPlain(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last()
in
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, result:Integer, i1:Integer, i2:Integer) = Tuple{flag:Boolean = true, result:Integer = 0, i1:Integer = 1, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      Tuple{flag:Boolean = false, result:Integer = -2, i1:Integer = null, i2:Integer = null}
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = false, result:Integer = -1, i1:Integer = null, i2:Integer = null}
        else
          if e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect then
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = iter.i1 + 1, i2:Integer = 2}
            else
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = iter.i1 + 1, i2:Integer = 1}
            endif
          endif
        endif
      else
        if e = firstCause then
          if e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 2, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect then
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 2, i2:Integer = 2}
            else
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 2, i2:Integer = 1}
            endif
          endif
        else
          if e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect then
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, i2:Integer = 2}
            else
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, i2:Integer = 1}
            endif
          endif
        endif
      endif
    endif
  else
    iter
  endif
).result >= -1

--modified on 18/08/2015
def: checkPatternPrecedenceManyManyAtLeastMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, i2:Integer) = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1} |
  if iter.flag then
    let e:String = elem.event in
    if iter.midCriticalInstant > 0 and elem.timestamp >= iter.midCriticalInstant then
      Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, i2:Integer = null} -- satisfaction
    else
      if iter.i2 = effectSize and e = lastEffect then
        Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2, i1:Integer = null, i2:Integer = null} -- violation
      else
        if iter.i1 > 1 and e = causes->at(iter.i1) then
          if iter.i1 = causeSize then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + distance, i1:Integer = 1, i2:Integer = 1}
          else
            if e = effects->at(iter.i2) then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1} -- a potential violation to time distance
            else
              if e = firstEffect then
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2} -- a potential violation
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1}
              endif
            endif
          endif
        else
          if iter.midCriticalInstant = 0 and e = firstCause then
            if e = effects->at(iter.i2) then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = iter.i2 + 1}
            else
              if e = firstEffect then
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 2} -- a potential violation
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 1}
              endif
            endif
          else
            if e = effects->at(iter.i2) then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = iter.i2 + 1}
            else
              if e = firstEffect then
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2} -- a potential violation
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1}
              endif
            endif
          endif
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstant >= -1

--modified on 18/08/2015
def: checkPatternPrecedenceManyManyAtMostMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, i2:Integer) = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      Tuple{flag:Boolean = false, midCriticalInstant:Integer = null, i1:Integer = null, i2:Integer = null}
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + distance, i1:Integer = 1, i2:Integer = 1}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 2}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 1}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1}
            endif
          endif
        endif
      endif
    endif
  else
    iter
  endif
).flag

--modified on 19/08/2015
def: checkPatternPrecedenceManyManyExactlyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), i1:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, i1:Integer = 1, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null, i1:Integer = null, i2:Integer = null}
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(elem.timestamp+distance), i1:Integer = 1, i2:Integer = 1}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect then
              let t:Integer = elem.timestamp in
              if iter.midCriticalInstants->includes(t) then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = iter.i1 + 1, i2:Integer = 1}
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = iter.i1 + 1, i2:Integer = 2}
              endif
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = iter.i1 + 1, i2:Integer = 1}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 2, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect then
              let t:Integer = elem.timestamp in
              if iter.midCriticalInstants->includes(t) then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 2, i2:Integer = 1}
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 2, i2:Integer = 2}
              endif
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 2, i2:Integer = 1}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect then
              let t:Integer = elem.timestamp in
              if iter.midCriticalInstants->includes(t) then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 1, i2:Integer = 1}
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, i2:Integer = 2}
              endif
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, i2:Integer = 1}
            endif
          endif
        endif
      endif
    endif
  else
    iter
  endif
).flag

--modified on 11/06/2015
def: checkPatternPrecedenceManyManyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:tempsy::TimeDistance, effects:Sequence(String)):Boolean =
let value:Integer = distance.value, which:tempsy::ComparingOperator=distance.comparingOperator in
if which = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceManyManyAtLeastMid(subtrace, causes, value, effects)
else
  if which = tempsy::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceManyManyAtMostMid(subtrace, causes, value, effects)
  else
    self.checkPatternPrecedenceManyManyExactlyMid(subtrace, causes, value, effects)
  endif
endif

--modified on 18/08/2015
def: checkPatternPrecedenceManyManyLeft(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last()
in
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, result:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer) = Tuple{flag:Boolean = true, result:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      Tuple{flag:Boolean = false, result:Integer = -2, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = false, result:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
        else
          let i11:Integer = iter.i1 + 1 in
          if e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect then
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 2}
            else
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 1}
            endif
          endif
        endif
      else
        if e = firstCause then
          if e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect then
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 2}
            else
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1}
            endif
          endif
        else
          if e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect then
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2}
            else
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
            endif
          endif
        endif
      endif
    endif
  else
    iter
  endif
).result >= -1

--modified on 18/08/2015
def: checkPatternPrecedenceManyManyLeftAtLeastMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer) = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.midCriticalInstant > 0 and elem.timestamp >= iter.midCriticalInstant then
      Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null} -- satisfaction
    else
      if iter.i2 = effectSize and e = lastEffect then
        Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null} -- violation
      else
        if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
          if iter.i1 = causeSize then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
          else
            let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value in
            if e = effects->at(iter.i2) then -- for instance {causes: [a,b,c], effects: [d,a,b]}, when i1 = 1, i2 = 2 or i1 = 2, i2 = 3. But it is not possible i1 equals to causeSize, since causes cannot be a sublist of effects.
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = iter.i2 + 1}
            else
              if e = firstEffect then
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 2} -- a potential violation
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 1}
              endif
            endif
          endif
        else
          if iter.midCriticalInstant = 0 and e = firstCause then
            if e = effects->at(iter.i2) then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = iter.i2 + 1}
            else
              if e = firstEffect then
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 2} -- a potential violation
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1}
              endif
            endif
          else
            if e = effects->at(iter.i2) then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1}
            else
              if e = firstEffect then
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2} -- a potential violation
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
              endif
            endif
          endif
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstant >= -1

--modified on 18/08/2015
def: checkPatternPrecedenceManyManyLeftAtMostMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      Tuple{flag:Boolean = false, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
        else
          let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value in
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 2}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 1}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 2}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
            endif
          endif
        endif
      endif
    endif
  else
    iter
  endif
).flag

--modified on 19/08/2015
def: checkPatternPrecedenceManyManyLeftExactlyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), i1:Integer, causeCriticalInstant:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(elem.timestamp+midDistance), i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
        else
          let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value in
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect then
              let t:Integer = elem.timestamp in
              if iter.midCriticalInstants->includes(t) then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 1}
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 2}
              endif
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 1}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect then
              let t:Integer = elem.timestamp in
              if iter.midCriticalInstants->includes(t) then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1}
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 2}
              endif
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1}
          else
            if e = firstEffect then
              let t:Integer = elem.timestamp in
              if iter.midCriticalInstants->includes(t) then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2}
              endif
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
            endif
          endif
        endif
      endif
    endif
  else
    iter
  endif
).flag

--modified on 11/06/2015
def: checkPatternPrecedenceManyManyLeftMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:tempsy::TimeDistance, effects:Sequence(String)):Boolean =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator=midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceManyManyLeftAtLeastMid(subtrace, causes, causeDistances, midValue, effects)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceManyManyLeftAtMostMid(subtrace, causes, causeDistances, midValue, effects)
  else
    self.checkPatternPrecedenceManyManyLeftExactlyMid(subtrace, causes, causeDistances, midValue, effects)
  endif
endif

--modified on 19/08/2015
def: checkPatternPrecedenceManyManyRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, result:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, result:Integer = 0, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      Tuple{flag:Boolean = false, result:Integer = -2, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = false, result:Integer = -1, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect then
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
            else
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 2, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect then
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 2, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
            else
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 2, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect then
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
            else
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        endif
      endif
    endif
  else
    iter
  endif
).result >= -1

--modified on 19/08/2015
def: checkPatternPrecedenceManyManyAtLeastMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.midCriticalInstant > 0 and elem.timestamp >= iter.midCriticalInstant then
      Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null} -- satisfaction
    else
      if iter.i2 = effectSize and e = lastEffect then
        Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null} -- violation
      else
        if iter.i1 > 1 and e = causes->at(iter.i1) then
          if iter.i1 = causeSize then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + midDistance, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          else
            if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
            else
              if e = firstEffect then
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance} -- a potential violation
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              endif
            endif
          endif
        else
          if iter.midCriticalInstant = 0 and e = firstCause then
            if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
            else
              if e = firstEffect then
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance} -- a potential violation
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              endif
            endif
          else
            if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
            else
              if e = firstEffect then--midCriticalInstant is either 0 or midCriticalInstant > elem.timestamp
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance} -- a potential violation
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              endif
            endif
          endif
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstant >= -1

--modified on 19/08/2015
def: checkPatternPrecedenceManyManyAtMostMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      Tuple{flag:Boolean = false, midCriticalInstant:Integer = null, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + midDistance, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        endif
      endif
    endif
  else
    iter
  endif
).flag

--modified on 19/08/2015
def: checkPatternPrecedenceManyManyExactlyMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), i1:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(elem.timestamp+midDistance), i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect then
              let t:Integer = elem.timestamp in
              if iter.midCriticalInstants->includes(t) then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
              endif
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 2, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect then
              let t:Integer = elem.timestamp in
              if iter.midCriticalInstants->includes(t) then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 2, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 2, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
              endif
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 2, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect then
              let t:Integer = elem.timestamp in
              if iter.midCriticalInstants->includes(t) then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
              endif
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        endif
      endif
    endif
  else
    iter
  endif
).flag

--modified on 12/06/2015
def: checkPatternPrecedenceManyManyMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), midDistance:tempsy::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator=midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceManyManyAtLeastMidRight(subtrace, causes, midValue, effects, effectDistances)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceManyManyAtMostMidRight(subtrace, causes, midValue, effects, effectDistances)
  else
    self.checkPatternPrecedenceManyManyExactlyMidRight(subtrace, causes, midValue, effects, effectDistances)
  endif
endif

--modified on 19/08/2015
def: checkPatternPrecedenceManyManyLeftRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, result:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, result:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      Tuple{flag:Boolean = false, result:Integer = -2, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = false, result:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
        else
          let i11:Integer = iter.i1 + 1 in
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect then
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
            else
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect then
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
            else
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect then
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
            else
              Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        endif
      endif
    endif
  else
    iter
  endif
).result >= -1

--modified on 19/08/2015
def: checkPatternPrecedenceManyManyLeftAtLeastMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.midCriticalInstant > 0 and elem.timestamp >= iter.midCriticalInstant then
      Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null} -- satisfaction
    else
      if iter.i2 = effectSize and e = lastEffect then
        Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null} -- violation
      else
        if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
          if iter.i1 = causeSize then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          else
            let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value in
            if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
            else
              if e = firstEffect then
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance} -- a potential violation
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              endif
            endif
          endif
        else
          if iter.midCriticalInstant = 0 and e = firstCause then
            if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
            else
              if e = firstEffect then
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance} -- a potential violation
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              endif
            endif
          else
            if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
            else
              if e = firstEffect then
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance} -- a potential violation
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              endif
            endif
          endif
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstant >= -1

--modified on 19/08/2015
def: checkPatternPrecedenceManyManyLeftAtMostMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      Tuple{flag:Boolean = false, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value in
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect and elem.timestamp > iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp + secondEffectDistance}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        endif
      endif
    endif
  else
    iter
  endif
).flag

--modified on 19/08/2015
def: checkPatternPrecedenceManyManyLeftExactlyMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  firstCause:String = causes->first(),
  secondCauseDistance:Integer = causeDistances->at(2).value,
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  lastEffect:String = effects->last(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event in
    if iter.i2 = effectSize and e = lastEffect then
      Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
    else
      if iter.i1 > 1 and e = causes->at(iter.i1) and self.compare(elem.timestamp, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(elem.timestamp+midDistance), i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp + causeDistances->at(i11).value in
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect then
              let t:Integer = elem.timestamp in
              if iter.midCriticalInstants->includes(t) then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
              endif
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        endif
      else
        if e = firstCause then
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect then
              let t:Integer = elem.timestamp in
              if iter.midCriticalInstants->includes(t) then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
              endif
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 2, causeCriticalInstant:Integer = elem.timestamp + secondCauseDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(elem.timestamp, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp + effectDistances->at(i22).value}
          else
            if e = firstEffect then
              let t:Integer = elem.timestamp in
              if iter.midCriticalInstants->includes(t) then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              else
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
              endif
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          endif
        endif
      endif
    endif
  else
    iter
  endif
).flag

--modified on 12/06/2015
def: checkPatternPrecedenceManyManyLeftMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:tempsy::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let midValue:Integer = midDistance.value, midWhich:tempsy::ComparingOperator=midDistance.comparingOperator in
if midWhich = tempsy::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceManyManyLeftAtLeastMidRight(subtrace, causes, causeDistances, midValue, effects, effectDistances)
else
  if midWhich = tempsy::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceManyManyLeftAtMostMidRight(subtrace, causes, causeDistances, midValue, effects, effectDistances)
  else
    self.checkPatternPrecedenceManyManyLeftExactlyMidRight(subtrace, causes, causeDistances, midValue, effects, effectDistances)
  endif
endif

def: checkPatternPrecedence(subtrace:OrderedSet(trace::TraceElement), pattern:tempsy::Pattern):Boolean =
--check the satisfiability of the precedence pattern 'cause preceding effect'
--in the first event in the chain 'effect', it may contains time distance to the last event in the chain 'cause'
if subtrace->isEmpty() then
  true
else
  let orderPattern:tempsy::OrderPattern = pattern.oclAsType(tempsy::OrderPattern),
      causes:Sequence(String) = orderPattern.block1.event.name,
      causeDistances:Sequence(Tuple(which:Integer, value:Integer)) = self.loadDistances(orderPattern.block1.timeDistance),
      causeSize:Integer = causes->size(),
      effects:Sequence(String) = orderPattern.block2.event.name,
      effectDistances:Sequence(Tuple(which:Integer, value:Integer)) = self.loadDistances(orderPattern.block2.timeDistance),
      effectSize:Integer = effects->size()
  in
  if causeDistances->isEmpty() then
    if effectDistances->isEmpty() then
      if orderPattern.timeDistance->isEmpty() then
        if causeSize = 1 then
          let cause:String = causes->first() in
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.checkPatternPrecedenceOneOnePlain(subtrace, cause, effect)
          else
            self.checkPatternPrecedenceOneManyPlain(subtrace, cause, effects)
          endif
        else
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.checkPatternPrecedenceManyOnePlain(subtrace, causes, effect)
          else
            self.checkPatternPrecedenceManyManyPlain(subtrace, causes, effects)
          endif
        endif
      else
        if causeSize = 1 then
          let cause:String = causes->first() in
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.checkPatternPrecedenceOneOneMid(subtrace, cause, orderPattern.timeDistance, effect)
          else
            self.checkPatternPrecedenceOneManyMid(subtrace, cause, orderPattern.timeDistance, effects)
          endif
        else
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.checkPatternPrecedenceManyOneMid(subtrace, causes, orderPattern.timeDistance, effect)
          else
            self.checkPatternPrecedenceManyManyMid(subtrace, causes, orderPattern.timeDistance, effects)
          endif
        endif
      endif
    else
      if orderPattern.timeDistance->isEmpty() then
        if causeSize = 1 then
          let cause:String = causes->first() in
          self.checkPatternPrecedenceOneManyRight(subtrace, cause, effects, effectDistances)
        else
          self.checkPatternPrecedenceManyManyRight(subtrace, causes, effects, effectDistances)
        endif
      else
        if causeSize = 1 then
          let cause:String = causes->first() in
          self.checkPatternPrecedenceOneManyMidRight(subtrace, cause, orderPattern.timeDistance, effects, effectDistances)
        else
          self.checkPatternPrecedenceManyManyMidRight(subtrace, causes, orderPattern.timeDistance, effects, effectDistances)
        endif
      endif
    endif
  else
    if effectDistances->isEmpty() then
      if orderPattern.timeDistance->isEmpty() then
        if effectSize = 1 then
          let effect:String = effects->first() in
          self.checkPatternPrecedenceManyOneLeft(subtrace, causes, causeDistances, effect)
        else
          self.checkPatternPrecedenceManyManyLeft(subtrace, causes, causeDistances, effects)
        endif
      else
        if effectSize = 1 then
          let effect:String = effects->first() in
          self.checkPatternPrecedenceManyOneLeftMid(subtrace, causes, causeDistances, orderPattern.timeDistance, effect)
        else
          self.checkPatternPrecedenceManyManyLeftMid(subtrace, causes, causeDistances, orderPattern.timeDistance, effects)
        endif
      endif
    else
      if orderPattern.timeDistance->isEmpty() then
        self.checkPatternPrecedenceManyManyLeftRight(subtrace, causes, causeDistances, effects, effectDistances)
      else
        self.checkPatternPrecedenceManyManyLeftMidRight(subtrace, causes, causeDistances, orderPattern.timeDistance, effects, effectDistances)
      endif
    endif
  endif 
endif

def: checkPatternExistence(subtrace:OrderedSet(trace::TraceElement), pattern:tempsy::Pattern):Boolean =
--check the satisfiability of the existence pattern 'pattern'
if subtrace->isEmpty() then
  true
else
  let occPattern:tempsy::OccurrencePattern = pattern.oclAsType(tempsy::OccurrencePattern), eventName:String = occPattern.event.name in
  if occPattern.comparingOperator->notEmpty() then
    let comparingOperator:tempsy::ComparingOperator = occPattern.comparingOperator, n:Integer = occPattern.times, count:Integer = subtrace.event->count(eventName) in
    if tempsy::ComparingOperator::ATLEAST = comparingOperator then
      count >= n
    else
      if tempsy::ComparingOperator::ATMOST = comparingOperator then
        count <= n
      else
        count = n
      endif
    endif
  else
    subtrace.event->includes(eventName)
  endif
endif

def: checkPatternAbsence(subtrace:OrderedSet(trace::TraceElement), pattern:tempsy::Pattern):Boolean = 
--check the satisfiability of the absence pattern 'pattern'
if subtrace->isEmpty() then
  true
else
  let occPattern:tempsy::OccurrencePattern = pattern.oclAsType(tempsy::OccurrencePattern), eventName:String = occPattern.event.name in
  if occPattern.comparingOperator->notEmpty() then
    subtrace.event->count(eventName) <> occPattern.times
  else
    subtrace.event->excludes(eventName)
  endif
endif

def: checkPatternUniversality(subtrace:OrderedSet(trace::TraceElement), pattern:tempsy::Pattern):Boolean = 
--check the satisfiability of the universality pattern 'always eventName'
let eventName:String = pattern.oclAsType(tempsy::Universality).event.name in
subtrace->forAll(event = eventName)


endpackage