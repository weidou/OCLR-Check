import 'platform:/resource/lu.svv.offline/models/oclr.ecore#/'
import 'platform:/resource/lu.svv.offline/models/trace.ecore#/'
import 'platform:/resource/lu.svv.offline/models/check.ecore#/'

package check

context Monitor

--------------------  Scopes  ----------------------

def: ordinalIndexOf(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer):Integer =
--find the index of the [n]th occurrence of the event 'eventName'
let eventTrace:OrderedSet(trace::TraceElement) = trace->select(elem | eventName = elem.event.name) in
if eventTrace->isEmpty() or eventTrace->size() < n or n < 1 then
  -1
else
  eventTrace->at(n).index
endif

def: atLeastBefore(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):OrderedSet(trace::TraceElement) =
--return the scope of 'before [n] eventName at least timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n) in
if 1 <> position.abs() then
  if 1 = timeDistance then
    trace->subOrderedSet(1, position-1)
  else
    let toTimeStamp:Integer = trace->at(position).timestamp.value in 
    trace->select(elem | toTimeStamp - timeDistance >= elem.timestamp.value) 
  endif
else
  OrderedSet{}
endif

def: atMostBefore(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):OrderedSet(trace::TraceElement) =
--return the scope of 'before [n] eventName at most timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n) in
if -1 <> position then
  let toTimeStamp:Integer = trace->at(position).timestamp.value in 
  trace->select(elem | toTimeStamp - timeDistance <= elem.timestamp.value and toTimeStamp >= elem.timestamp.value)
else
  OrderedSet{}
endif

def: exactlyBefore(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):OrderedSet(trace::TraceElement) =
--return the scope of 'before [n] eventName exactly timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n) in
if -1 <> position then
  let toTimeStamp:Integer = trace->at(position).timestamp.value in 
  trace->select(elem | toTimeStamp - timeDistance = elem.timestamp.value)
else
  OrderedSet{}
endif

def: applyScopeBefore(trace:trace::Trace, scope:oclr::Scope):OrderedSet(trace::TraceElement) =
--return the scope of 'before boundary'
--'boundary' : '[n] eventName [comparingOperator timeDistance tu]'
let boundary:oclr::Boundary = scope.oclAsType(oclr::UniScope).boundary, eventName:String = boundary.event.name in
if boundary.timeDistance->notEmpty() then
  let comparingOperator:oclr::ComparingOperator = boundary.timeDistance.comparingOperator, timeDistance:Integer = boundary.timeDistance.value in
  if boundary.ordinal > 0 then
    let n:Integer = boundary.ordinal in
    if oclr::ComparingOperator::ATLEAST = comparingOperator then
      self.atLeastBefore(trace.traceElements, eventName,n,timeDistance) 
    else
      if oclr::ComparingOperator::ATMOST = comparingOperator then
        self.atMostBefore(trace.traceElements, eventName,n,timeDistance)
      else
        self.exactlyBefore(trace.traceElements, eventName,n,timeDistance)
      endif
    endif
  else
    if oclr::ComparingOperator::ATLEAST = comparingOperator then
      self.atLeastBefore(trace.traceElements, eventName,1,timeDistance)
    else
      if oclr::ComparingOperator::ATMOST = comparingOperator then
        self.atMostBefore(trace.traceElements, eventName,1,timeDistance)
      else
        self.exactlyBefore(trace.traceElements, eventName,1,timeDistance)
      endif
    endif
  endif
else
  if boundary.ordinal > 0 then
    let n:Integer = boundary.ordinal in
    self.atLeastBefore(trace.traceElements, eventName,n,1)
  else
    self.atLeastBefore(trace.traceElements, eventName,1,1)
  endif
endif

def: atLeastAfter(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):OrderedSet(trace::TraceElement) =
--return the scope of 'after [n] eventName at least timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n), size:Integer = trace->size() in
if -1 <> position and size <> position then
  if 1 = timeDistance then
    trace->subOrderedSet(position+1, size)
  else
    let fromTimeStamp:Integer = trace->at(position).timestamp.value in 
    trace->select(elem | fromTimeStamp + timeDistance <= elem.timestamp.value)
  endif
else
  OrderedSet{}
endif

def: atMostAfter(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):OrderedSet(trace::TraceElement) =
--return the scope of 'after [n] eventName at most timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n) in
if -1 <> position then
  let fromTimeStamp:Integer = trace->at(position).timestamp.value in 
  trace->select(elem | fromTimeStamp <= elem.timestamp.value and fromTimeStamp + timeDistance >= elem.timestamp.value)
else
  OrderedSet{}
endif

def: exactlyAfter(trace:OrderedSet(trace::TraceElement), eventName:String, n:Integer, timeDistance:Integer):OrderedSet(trace::TraceElement) =
--return the scope of 'after [n] eventName exactly timeDistance tu'
let position:Integer = ordinalIndexOf(trace, eventName, n) in
if -1 <> position then
  let fromTimeStamp:Integer = trace->at(position).timestamp.value in 
  trace->select(elem | fromTimeStamp + timeDistance = elem.timestamp.value)
else
  OrderedSet{}
endif

def: applyScopeAfter(trace:trace::Trace, scope:oclr::Scope):OrderedSet(trace::TraceElement) =
--return the scope of 'after boundary'
--'boundary' : '[n] eventName [comparingOperator timeDistance tu]'
let boundary:oclr::Boundary = scope.oclAsType(oclr::UniScope).boundary, eventName:String = boundary.event.name in
if boundary.timeDistance->notEmpty() then
  let comparingOperator:oclr::ComparingOperator = boundary.timeDistance.comparingOperator, timeDistance:Integer = boundary.timeDistance.value in
  if boundary.ordinal > 0 then
      let n:Integer = boundary.ordinal in
    if oclr::ComparingOperator::ATLEAST = comparingOperator then
      self.atLeastAfter(trace.traceElements, eventName, n, timeDistance)
    else if oclr::ComparingOperator::ATMOST = comparingOperator then
        self.atMostAfter(trace.traceElements, eventName,n,timeDistance)
      else 
        self.exactlyAfter(trace.traceElements, eventName, n, timeDistance)
      endif 
    endif
  else
    if oclr::ComparingOperator::ATLEAST = comparingOperator then
      self.atLeastAfter(trace.traceElements, eventName, 1,timeDistance)
    else if oclr::ComparingOperator::ATMOST = comparingOperator then
        self.atMostAfter(trace.traceElements, eventName, 1, timeDistance)
      else 
        self.exactlyAfter(trace.traceElements, eventName, 1, timeDistance)
      endif 
    endif     
  endif
else
  if boundary.ordinal > 0 then
      let n:Integer = boundary.ordinal in
    self.atLeastAfter(trace.traceElements, eventName, n, 1)         
    else  
    self.atLeastAfter(trace.traceElements, eventName, 1, 1)
  endif
endif

def: applySpecialBetweenAnd(trace:OrderedSet(trace::TraceElement), eventNameBegin:String, nBegin:Integer, timeDistanceBegin:Integer, eventNameEnd:String, nEnd:Integer, timeDistanceEnd:Integer):OrderedSet(trace::TraceElement) = 
--return the scope of 'between nBegin eventNameBegin at least timeDistanceBegin tu and nBegin eventNameEnd at least timeDistanceEnd tu'
let t:Tuple(indexBegin:Integer, indexEnd:Integer, count:Integer) = trace->iterate(elem:trace::TraceElement;
    iter:Tuple(indexBegin:Integer, indexEnd:Integer, count:Integer) = Tuple{indexBegin:Integer = 0, indexEnd:Integer = 0, count:Integer = 0} |
    if iter.indexBegin = 0 then
      if elem.event.name = eventNameBegin then
        let nextBeginCount:Integer = iter.count+1 in
        if nextBeginCount = nBegin then
          Tuple{indexBegin:Integer = elem.index+1, indexEnd:Integer = iter.indexEnd, count:Integer = 0}
        else
          Tuple{indexBegin:Integer = iter.indexBegin, indexEnd:Integer = iter.indexEnd, count:Integer = nextBeginCount}
        endif
      else
        iter
      endif
    else
      if iter.indexEnd = 0 then
        if elem.event.name = eventNameEnd then
          let nextEndCount:Integer = iter.count+1 in
          if nextEndCount = nEnd then
            Tuple{indexBegin:Integer = iter.indexBegin, indexEnd:Integer = elem.index-1, count:Integer = nEnd}  
          else
            Tuple{indexBegin:Integer = iter.indexBegin, indexEnd:Integer = iter.indexEnd, count:Integer = nextEndCount}
          endif
        else
          iter
        endif
      else
        iter
      endif
    endif
  )
in
let i:Integer = t.indexBegin,
  j:Integer = t.indexEnd,
  timestampBegin:Integer = trace->at(i-1).timestamp.value+timeDistanceBegin,
  timestampEnd:Integer = trace->at(j+1).timestamp.value-timeDistanceEnd
in
if i > 0 and j > 0 and i <= j then
  if timeDistanceBegin = 1 and timeDistanceEnd = 1 then
    trace->subOrderedSet(i, j)
  else
    trace->subOrderedSet(i, j)->select(elem | elem.timestamp.value >= timestampBegin and elem.timestamp.value <= timestampEnd)
  endif
else
  OrderedSet{}
endif

def: applyOriginalBetweenAnd(trace:OrderedSet(trace::TraceElement), eventNameBegin:String, eventNameEnd:String):Sequence(OrderedSet(trace::TraceElement)) =
--return the scope of 'between eventNameBegin and eventNameEnd'
trace->iterate(elem:trace::TraceElement;
  iter:Tuple(result:Sequence(OrderedSet(trace::TraceElement)), i:Integer)
  =Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, i:Integer = 0} |
  if iter.i = 0 then
    if elem.event.name = eventNameBegin then
      Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = elem.index}
    else
      iter
    endif
  else
    if elem.event.name = eventNameEnd then
      let i:Integer = iter.i+1, j:Integer = elem.index-1 in
      if i <= j then
        Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = iter.result->append(trace->subOrderedSet(i, j)), i:Integer = 0}
      else
        Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = 0}
      endif
    else
      Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = iter.i}
    endif
  endif
).result


def: applyOriginalBetweenAnd(trace:OrderedSet(trace::TraceElement), eventNameBegin:String, distanceBegin:Integer, eventNameEnd:String):Sequence(OrderedSet(trace::TraceElement)) =
--return the scope of 'between eventNameBegin at least distanceBegin tu and eventNameEnd'
trace->iterate(elem:trace::TraceElement;
  iter:Tuple(result:Sequence(OrderedSet(trace::TraceElement)), i:Integer, criticalTime:Integer)
  =Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, i:Integer = 0, criticalTime:Integer = 0} |
  let e:String = elem.event.name in
  if iter.i = 0 then
    if e = eventNameBegin then
      Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = elem.index, criticalTime:Integer = elem.timestamp.value + distanceBegin}
    else
      iter
    endif
  else
    if e = eventNameEnd then
      let t:Integer = elem.timestamp.value, i:Integer = iter.i + 1, j:Integer = elem.index - 1, t1:Integer = iter.criticalTime in
      if i <= j and t1 < t then
        Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = iter.result->append(trace->subOrderedSet(i, j)->select(segElem | segElem.timestamp.value >= t1)), i:Integer = 0, criticalTime:Integer = iter.criticalTime}
      else
        Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = 0, criticalTime:Integer = iter.criticalTime}
      endif
    else
      iter
    endif
  endif
).result

def: applyOriginalBetweenAnd(trace:OrderedSet(trace::TraceElement), eventNameBegin:String, eventNameEnd:String, distanceEnd:Integer):Sequence(OrderedSet(trace::TraceElement)) =
--return the scope of 'between eventNameBegin and at least distanceEnd tu eventNameEnd'
trace->iterate(elem:trace::TraceElement;
  iter:Tuple(result:Sequence(OrderedSet(trace::TraceElement)), i:Integer, criticalTime:Integer)
  =Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, i:Integer = 0, criticalTime:Integer = 0} |
  let e:String = elem.event.name in
  if iter.i = 0 then
    if e = eventNameBegin then
      Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = elem.index, criticalTime:Integer = elem.timestamp.value + 1}
    else
      iter
    endif
  else
    if e = eventNameEnd then
      let t:Integer = elem.timestamp.value, i:Integer = iter.i + 1, j:Integer = elem.index - 1, t1:Integer = iter.criticalTime, t2:Integer = t - distanceEnd in
      if i <= j and t1 <= t2 then
        Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = iter.result->append(trace->subOrderedSet(i, j)->select(segElem | segElem.timestamp.value <= t2)), i:Integer = 0, criticalTime:Integer = iter.criticalTime}
      else
        Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = 0, criticalTime:Integer = iter.criticalTime}
      endif
    else
      iter
    endif
  endif
).result

def: applyOriginalBetweenAnd(trace:OrderedSet(trace::TraceElement), eventNameBegin:String, distanceBegin:Integer, eventNameEnd:String, distanceEnd:Integer):Sequence(OrderedSet(trace::TraceElement)) =
--return the scope of 'between eventNameBegin at least distanceBegin tu and at least distanceEnd tu eventNameEnd'
trace->iterate(elem:trace::TraceElement;
  iter:Tuple(result:Sequence(OrderedSet(trace::TraceElement)), i:Integer, criticalTime:Integer)
  =Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, i:Integer = 0, criticalTime:Integer = 0} |
  let e:String = elem.event.name in
  if iter.i = 0 then
    if e = eventNameBegin then
      Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = elem.index, criticalTime:Integer = elem.timestamp.value + distanceBegin}
    else
      iter
    endif
  else
    if e = eventNameEnd then
      let t:Integer = elem.timestamp.value, i:Integer = iter.i + 1, j:Integer = elem.index - 1, t1:Integer = iter.criticalTime, t2:Integer = t - distanceEnd in
      if i <= j and t1 <= t2 then
        Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = iter.result->append(trace->subOrderedSet(i, j)->select(segElem | segElem.timestamp.value >= t1 and segElem.timestamp.value <= t2)), i:Integer = 0, criticalTime:Integer = iter.criticalTime}
      else
        Tuple{result:Sequence(OrderedSet(trace::TraceElement)) = iter.result, i:Integer = 0, criticalTime:Integer = iter.criticalTime}
      endif
    else
      iter
    endif
  endif
).result

def: applyScopeBetweenAnd(trace:trace::Trace, scope:oclr::Scope):Sequence(OrderedSet(trace::TraceElement)) = 
--return the scope of 'between boundaryBegin and boundaryEnd'
--i.e., 'between [nBegin] eventNameBegin [at least timeDistanceBegin] and [nEnd] eventNameEnd [at least timeDistanceEnd]'
let boundaryBegin:oclr::Boundary = scope.oclAsType(oclr::BiScope).boundaryBegin,
  boundaryEnd:oclr::Boundary = scope.oclAsType(oclr::BiScope).boundaryEnd,
  eventNameBegin:String = boundaryBegin.event.name,
  eventNameEnd:String = boundaryEnd.event.name
in
if boundaryBegin.timeDistance->notEmpty() then
  let timeDistanceBegin:Integer = boundaryBegin.timeDistance.value in 
  if boundaryEnd.timeDistance->notEmpty() then
    let timeDistanceEnd:Integer = boundaryEnd.timeDistance.value in
    if boundaryBegin.ordinal > 0 then
      let result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, nBegin:Integer = boundaryBegin.ordinal in
      if boundaryEnd.ordinal > 0 then
        let nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, timeDistanceBegin, eventNameEnd, nEnd, timeDistanceEnd))
      else
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, timeDistanceBegin, eventNameEnd, 1, timeDistanceEnd))
      endif
    else
      if boundaryEnd.ordinal > 0 then
        let result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, 1, timeDistanceBegin, eventNameEnd, nEnd, timeDistanceEnd))
      else
        self.applyOriginalBetweenAnd(trace.traceElements, eventNameBegin, timeDistanceBegin, eventNameEnd, timeDistanceEnd)
      endif
    endif
  else
    if boundaryBegin.ordinal > 0 then
      let result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, nBegin:Integer = boundaryBegin.ordinal in
      if boundaryEnd.ordinal > 0 then
        let nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, timeDistanceBegin, eventNameEnd, nEnd, 1))
      else
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, timeDistanceBegin, eventNameEnd, 1, 1))
      endif
    else
      if boundaryEnd.ordinal > 0 then
        let result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, 1, timeDistanceBegin, eventNameEnd, nEnd, 1))
      else
        self.applyOriginalBetweenAnd(trace.traceElements, eventNameBegin, timeDistanceBegin, eventNameEnd)
      endif
    endif
  endif
else
  if boundaryEnd.timeDistance->notEmpty() then
    let timeDistanceEnd:Integer = boundaryEnd.timeDistance.value in
    if boundaryBegin.ordinal > 0 then
      let result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, nBegin:Integer = boundaryBegin.ordinal in
      if boundaryEnd.ordinal > 0 then
        let nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, 1, eventNameEnd, nEnd, timeDistanceEnd))
      else
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, 1, eventNameEnd, 1, timeDistanceEnd))
      endif
    else
      if boundaryEnd.ordinal > 0 then
        let result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, 1, 1, eventNameEnd, nEnd, timeDistanceEnd))
      else
        self.applyOriginalBetweenAnd(trace.traceElements, eventNameBegin, eventNameEnd, timeDistanceEnd)
      endif
    endif
  else
    if boundaryBegin.ordinal > 0 then
      let result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, nBegin:Integer = boundaryBegin.ordinal in
      if boundaryEnd.ordinal > 0 then
        let nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, 1, eventNameEnd, nEnd, 1))
      else
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, nBegin, 1, eventNameEnd, 1, 1))
      endif
    else
      if boundaryEnd.ordinal > 0 then
        let result:Sequence(OrderedSet(trace::TraceElement)) = Sequence{}, nEnd:Integer = boundaryEnd.ordinal in
        result->append(self.applySpecialBetweenAnd(trace.traceElements, eventNameBegin, 1, 1, eventNameEnd, nEnd, 1))
      else
        self.applyOriginalBetweenAnd(trace.traceElements, eventNameBegin, eventNameEnd)
      endif
    endif
  endif
endif

def: applyScopeGlobally(trace:trace::Trace, scope:oclr::Scope):OrderedSet(trace::TraceElement) = 
trace.traceElements

--------------------  Patterns  ----------------------

--NEW since 05/02/2015

def: compare(a:Integer, b:Integer, which:Integer):Boolean =
if which = 1 then --at least b tu
  a >= b
else
  if which = 2 then --at most b tu
    a <= b
  else
    if which = 3 then --exactly b tu
      a = b
    else
      true --no comparison is needed
    endif
  endif
endif

def: loadDistances(distances:Sequence(oclr::TimeDistance)):Sequence(Tuple(which:Integer, value:Integer)) =
if distances->forAll(elem | elem->isEmpty()) then
  Sequence{}
else
  distances->iterate(elem:oclr::TimeDistance; iter:Sequence(Tuple(which:Integer, value:Integer)) = Sequence{} |
    if elem->isEmpty() then
      iter->append(Tuple{which:Integer = 0, value:Integer = 1})
    else
      if oclr::ComparingOperator::ATLEAST = elem.comparingOperator then
        iter->append(Tuple{which:Integer = 1, value:Integer = elem.value})
      else
        if oclr::ComparingOperator::ATMOST = elem.comparingOperator then
          iter->append(Tuple{which:Integer = 2, value:Integer = elem.value})
        else
          iter->append(Tuple{which:Integer = 3, value:Integer = elem.value})
        endif
      endif
    endif
  )
endif

-- modified on 21/04/2015
def: checkPatternResponseOneOnePlain(subtrace:OrderedSet(trace::TraceElement), cause:String, effect:String):Boolean =
subtrace->iterate(
  elem:trace::TraceElement;
  result:Boolean = true
  |
  let e:String = elem.event.name in
  if e = cause then
    false
  else
    if e = effect then
      true
    else
      result
    endif
  endif
)

-- modified on 21/04/2015
def: checkPatternResponseOneOneAtLeastMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effect:String):Boolean =
subtrace->iterate(elem:trace::TraceElement;
  criticalInstant:Integer = 0
  |
  let e:String = elem.event.name in
  if e = cause then
    elem.timestamp.value + distance
  else
    if e = effect and elem.timestamp.value >= criticalInstant then
      0
    else
      criticalInstant
    endif
  endif
) = 0

-- modified on 12/06/2015
def: checkPatternResponseOneOneAtMostMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effect:String):Boolean =
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstant:Integer)
  = Tuple{flag:Boolean = true, criticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if iter.criticalInstant = 0 and e = cause then
      Tuple{flag:Boolean = true, criticalInstant:Integer = elem.timestamp.value + distance}
    else
      if e = effect then
        if elem.timestamp.value <= iter.criticalInstant then
          Tuple{flag:Boolean = true, criticalInstant:Integer = 0}
        else
          Tuple{flag:Boolean = false, criticalInstant:Integer = -1} -- violation
        endif
      else
        iter
      endif
    endif
  else
    iter
  endif
).criticalInstant = 0

-- modified on 13/06/2015
def: checkPatternResponseOneOneExactlyMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effect:String):Boolean =
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstants:Sequence(Integer))
  = Tuple{flag:Boolean = true, criticalInstants:Sequence(Integer) = Sequence{}}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = cause then
      Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->append(elem.timestamp.value + distance)}
    else
      if e = effect and iter.criticalInstants->notEmpty() and iter.criticalInstants->first() >= elem.timestamp.value then
        let t:Integer = elem.timestamp.value in
        if t = iter.criticalInstants->first() then
          Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->excluding(t)}
        else
          Tuple{flag:Boolean = false, criticalInstants:Sequence(Integer) = Sequence{}}
        endif
      else
        iter
      endif
    endif
  else
    iter
  endif
).criticalInstants->isEmpty()

def: checkPatternResponseOneOneMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:oclr::TimeDistance, effect:String):Boolean =
let value:Integer = distance.value, which:oclr::ComparingOperator = distance.comparingOperator in
if which = oclr::ComparingOperator::ATLEAST then
  self.checkPatternResponseOneOneAtLeastMid(subtrace, cause, value, effect)
else
  if which = oclr::ComparingOperator::ATMOST then
    self.checkPatternResponseOneOneAtMostMid(subtrace, cause, value, effect)
  else
    self.checkPatternResponseOneOneExactlyMid(subtrace, cause, value, effect)
  endif
endif

--modified on 25/05/2015
def: checkPatternResponseOneManyPlain(subtrace:OrderedSet(trace::TraceElement), cause:String, effects:Sequence(String)):Boolean =
let effectSize:Integer = effects->size() in
subtrace->iterate(
  elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, i2:Integer) = Tuple{flag:Boolean = true, i2:Integer = 1}
  |
  let e:String = elem.event.name in
  if e = cause then
    Tuple{flag:Boolean = false, i2:Integer = 1}
  else
    if not iter.flag then
      if e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = true, i2:Integer = 1}
        else
          Tuple{flag:Boolean = iter.flag, i2:Integer = iter.i2 + 1}
        endif
      else
        Tuple{flag:Boolean = iter.flag, i2:Integer = 1}
      endif
    else
      iter
    endif
  endif
).flag

--modified on 25/05/2015
def: checkPatternResponseOneManyAtLeastMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effects:Sequence(String)):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first() 
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstant:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, criticalInstant:Integer = 0, i2:Integer = 1}
  |
  let e:String = elem.event.name in
  if e = cause then -- latest cause
    Tuple{flag:Boolean = false, criticalInstant:Integer = elem.timestamp.value + distance, i2:Integer = 1}
  else
    if not iter.flag then
      if iter.i2 = 1 and e = firstEffect then
        if elem.timestamp.value >= iter.criticalInstant then
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i2:Integer = 2}
        else
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i2:Integer = 1}
        endif
      else
        if e = effects->at(iter.i2) then
          if iter.i2 = effectSize then -- until effects->last(), the property is satisfied so far
            Tuple{flag:Boolean = true, criticalInstant:Integer = iter.criticalInstant, i2:Integer = 1}
          else
            Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i2:Integer = iter.i2 + 1}
          endif
        else
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i2:Integer = 1}
        endif
      endif
    else
      iter
    endif
  endif
).flag

--modified on 25/05/2015
def: checkPatternResponseOneManyAtMostMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effects:Sequence(String)):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstant:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, criticalInstant:Integer = 0, i2:Integer = 1}
  |
  let e:String = elem.event.name in
  if iter.flag then
    if iter.criticalInstant = 0 then
      if e = cause then
        Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = elem.timestamp.value + distance, i2:Integer = 1}
      else
        iter
      endif
    else
--      if elem.timestamp.value > iter.criticalInstant then -- early detecting violation
--        Tuple{flag:Boolean = false, criticalInstant:Integer = null, i2:Integer = null}
--      else
        if iter.i2 = 1 and e = firstEffect then
          if elem.timestamp.value <= iter.criticalInstant then
            Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i2:Integer = 2}
          else
            Tuple{flag:Boolean = false, criticalInstant:Integer = 0, i2:Integer = null}
          endif
        else
          if e = effects->at(iter.i2) then
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = 0, i2:Integer = 1}
            else
              Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i2:Integer = iter.i2 + 1}
            endif
          else
            Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i2:Integer = 1}
          endif
        endif
--      endif
    endif
  else
    iter
  endif
).criticalInstant = 0

--modified on 25/05/2015
def: checkPatternResponseOneManyExactlyMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effects:Sequence(String)):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstants:Sequence(Integer), criticalInstant:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, criticalInstants:Sequence(Integer) = Sequence{}, criticalInstant:Integer = 0, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = cause then
      let ct:Integer = elem.timestamp.value + distance in
      Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->append(ct), criticalInstant:Integer = ct, i2:Integer = 1}
    else
      if iter.criticalInstants->notEmpty() and elem.timestamp.value >= iter.criticalInstant then
        if elem.timestamp.value = iter.criticalInstant then
          if e = firstEffect then
            Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, criticalInstant:Integer = iter.criticalInstant, i2:Integer = 2}
          else
            Tuple{flag:Boolean = false, criticalInstants:Sequence(Integer) = Sequence{}, criticalInstant:Integer = null, i2:Integer = null}
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            if iter.i2 = effectSize then
              if iter.criticalInstants->size() = 1 then
                Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->excluding(iter.criticalInstant), criticalInstant:Integer = iter.criticalInstant, i2:Integer = 1}
              else
                let nextCriticalInstant:Integer = iter.criticalInstants->at(2) in
                Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->excluding(iter.criticalInstant), criticalInstant:Integer = nextCriticalInstant, i2:Integer = 1}
              endif
            else
              Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, criticalInstant:Integer = iter.criticalInstant, i2:Integer = iter.i2 + 1}
            endif
          else
            Tuple{flag:Boolean = false, criticalInstants:Sequence(Integer) = Sequence{}, criticalInstant:Integer = null, i2:Integer = null}
          endif
        endif
      else
        iter
      endif
    endif
  else
    iter
  endif
).criticalInstants->isEmpty()

--modified on 25/05/2015
def: checkPatternResponseOneManyMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:oclr::TimeDistance, effects:Sequence(String)):Boolean =
let value:Integer = distance.value, which:oclr::ComparingOperator = distance.comparingOperator in
if which = oclr::ComparingOperator::ATLEAST then
  self.checkPatternResponseOneManyAtLeastMid(subtrace, cause, value, effects)
else
  if which = oclr::ComparingOperator::ATMOST then
    self.checkPatternResponseOneManyAtMostMid(subtrace, cause, value, effects)
  else
    self.checkPatternResponseOneManyExactlyMid(subtrace, cause, value, effects)
  endif
endif

--modified on 27/05/2015
def: checkPatternResponseManyOnePlain(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), effect:String):Boolean =
let causeSize:Integer = causes->size() in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, i1:Integer) = Tuple{flag:Boolean = true, i1:Integer = 1}
  |
  let e:String = elem.event.name in
  if e = causes->at(iter.i1) then
    if iter.i1 = causeSize then
      Tuple{flag:Boolean = false, i1:Integer = 1}
    else
      Tuple{flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1}
    endif
  else
    if e = effect then
      Tuple{flag:Boolean = true, i1:Integer = 1}
    else
      Tuple{flag:Boolean = iter.flag, i1:Integer = 1}
    endif
  endif
).flag

-- modified on 21/04/2015
def: checkPatternResponseManyOneAtLeastMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effect:String):Boolean =
let causeSize:Integer = causes->size() in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(criticalInstant:Integer, i1:Integer) = Tuple{criticalInstant:Integer = 0, i1:Integer = 1} |
  let e:String = elem.event.name in
  if e = causes->at(iter.i1) then
    if iter.i1 = causeSize then
      Tuple{criticalInstant:Integer = elem.timestamp.value + distance, i1:Integer = 1}
    else
      Tuple{criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1}
    endif
  else
    if e = effect and elem.timestamp.value >= iter.criticalInstant then
      Tuple{criticalInstant:Integer = 0, i1:Integer = 1}
    else
      Tuple{criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1}
    endif
  endif
).criticalInstant = 0

-- modified on 13/06/2015
def: checkPatternResponseManyOneAtMostMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effect:String):Boolean =
let causeSize:Integer = causes->size() in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstant:Integer, i1:Integer)
  = Tuple{flag:Boolean = true, criticalInstant:Integer = 0, i1:Integer = 1} |
  let e:String = elem.event.name in
  if iter.flag then
    if iter.criticalInstant = 0 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = elem.timestamp.value + distance, i1:Integer = 1}
      else
        Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1}
      endif
    else
--      if elem.timestamp.value > iter.criticalInstant then -- early detecting violation
--        Tuple{flag:Boolean = false, criticalInstant:Integer = null, i1:Integer = null}
--      else
      if e = effect then
        if elem.timestamp.value <= iter.criticalInstant then
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = 0, i1:Integer = 1}
        else
          Tuple{flag:Boolean = false, criticalInstant:Integer = 0, i1:Integer = null}
        endif
      else
        Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1}
      endif
--      endif
    endif
  else
    iter
  endif
).criticalInstant = 0

-- modified on 10/06/2015
def: checkPatternResponseManyOneExactlyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effect:String):Boolean =
let causeSize:Integer = causes->size() in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstants:Sequence(Integer), criticalInstant:Integer, i1:Integer)
  = Tuple{flag:Boolean = true, criticalInstants:Sequence(Integer) = Sequence{}, criticalInstant:Integer = 0, i1:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event.name, t:Integer = elem.timestamp.value in
    if e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        let ct:Integer = t + distance in
        Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->append(ct), criticalInstant:Integer = ct, i1:Integer = 1}
      else
        Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1}
      endif
    else
      if iter.criticalInstants->notEmpty() and t >= iter.criticalInstant then
        if t = iter.criticalInstant and e = effect then
          if iter.criticalInstants->size() = 1 then
            Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->excluding(iter.criticalInstant), criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1}
          else
            let nextCriticalInstant:Integer = iter.criticalInstants->at(2) in
            Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->excluding(iter.criticalInstant), criticalInstant:Integer = nextCriticalInstant, i1:Integer = 1}
          endif
        else
          Tuple{flag:Boolean = false, criticalInstants:Sequence(Integer) = Sequence{}, criticalInstant:Integer = null, i1:Integer = null}
        endif
      else
        Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1}
      endif
    endif
  else
    iter
  endif
).criticalInstants->isEmpty()

def: checkPatternResponseManyOneMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:oclr::TimeDistance, effect:String):Boolean =
let value:Integer = distance.value, which:oclr::ComparingOperator = distance.comparingOperator in
if which = oclr::ComparingOperator::ATLEAST then
  self.checkPatternResponseManyOneAtLeastMid(subtrace, causes, value, effect)
else
  if which = oclr::ComparingOperator::ATMOST then
    self.checkPatternResponseManyOneAtMostMid(subtrace, causes, value, effect)
  else
    self.checkPatternResponseManyOneExactlyMid(subtrace, causes, value, effect)
  endif
endif

-- modified on 10/06/2015
def: checkPatternResponseManyManyPlain(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size() 
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, i1:Integer, i2:Integer) = Tuple{flag:Boolean = true, i1:Integer = 1, i2:Integer = 1}
  |
  let e:String = elem.event.name in
  if e = causes->at(iter.i1)  then
    if iter.i1 = causeSize then
      Tuple{flag:Boolean = false, i1:Integer = 1, i2:Integer = 1}
    else
      if e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = true, i1:Integer = 1, i2:Integer = 1}
        else
          Tuple{flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1}
        endif
      else
        Tuple{flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, i2:Integer = 1}
      endif
    endif
  else
    if not iter.flag and e = effects->at(iter.i2) then
      if iter.i2 = effectSize then
        Tuple{flag:Boolean = true, i1:Integer = 1, i2:Integer = 1}
      else
        Tuple{flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = iter.i2 + 1}
      endif
    else
      Tuple{flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = 1}
    endif
  endif
).flag

-- modified on 10/06/2015
def: checkPatternResponseManyManyAtLeastMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstant:Integer, i1:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, criticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1}
  |
  let e:String = elem.event.name in
  if e = causes->at(iter.i1)  then
    if iter.i1 = causeSize then
      Tuple{flag:Boolean = false, criticalInstant:Integer = elem.timestamp.value + distance, i1:Integer = 1, i2:Integer = 1}
    else
      if not iter.flag and e = effects->at(iter.i2) then
        if iter.i2 = 1 then
          if elem.timestamp.value >= iter.criticalInstant then
            Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2}
          else
            Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2}
          endif
        else
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = true, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = 1}
          else
            Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1}
          endif
        endif
      else
        Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1}
      endif
    endif
  else
    if not iter.flag and e = effects->at(iter.i2) then
      if iter.i2 = 1 then
        if elem.timestamp.value >= iter.criticalInstant then
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = 2}
        else
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = iter.i2}
        endif
      else
        if iter.i2 = effectSize then -- until effects->last(), the property is satisfied so far
          Tuple{flag:Boolean = true, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = 1}
        else
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = iter.i2 + 1}
        endif
      endif
    else
      Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = 1}
    endif
  endif
).flag

-- modified on 13/06/2015
def: checkPatternResponseManyManyAtMostMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstant:Integer, i1:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, criticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1}
  |
  let e:String = elem.event.name in
  if iter.flag then
    if iter.criticalInstant = 0 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = elem.timestamp.value + distance, i1:Integer = 1, i2:Integer = iter.i2}
      else
        Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1}
      endif
    else
--      if elem.timestamp.value > iter.criticalInstant then -- early detecting violation
--        Tuple{flag:Boolean = false, criticalInstant:Integer = null, i1:Integer = null, i2:Integer = null}
--      else
        if iter.i2 = 1 and e = firstEffect then
          if elem.timestamp.value <= iter.criticalInstant then
            Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = 2}
          else
            Tuple{flag:Boolean = false, criticalInstant:Integer = 0, i1:Integer = null, i2:Integer = null}
          endif
        else
          if e = effects->at(iter.i2) then
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = 0, i1:Integer = iter.i1, i2:Integer = 1}
            else
              Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1, i2:Integer = iter.i2 + 1}
            endif
          else
            Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = 1}
          endif
        endif
--      endif
    endif
  else
    iter
  endif
).criticalInstant = 0

-- modified on 10/06/2015
def: checkPatternResponseManyManyExactlyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstants:Sequence(Integer), criticalInstant:Integer, i1:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, criticalInstants:Sequence(Integer) = Sequence{}, criticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1} |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        let ct:Integer = elem.timestamp.value + distance in
        Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->append(ct), criticalInstant:Integer = ct, i1:Integer = 1, i2:Integer = 1}
      else
        if e = effects->at(iter.i2) and iter.criticalInstants->notEmpty() and elem.timestamp.value >= iter.criticalInstant then
          if elem.timestamp.value = iter.criticalInstant then
            if e = firstEffect then
              Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = 2}
            else
              Tuple{flag:Boolean = false, criticalInstants:Sequence(Integer) = Sequence{}, criticalInstant:Integer = null, i1:Integer = null, i2:Integer = null}
            endif
          else
            if iter.i2 > 1 then
              if iter.i2 = effectSize then
                if iter.criticalInstants->size() = 1 then
                  Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->excluding(iter.criticalInstant), criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = 1}
                else
                  let nextCriticalInstant:Integer = iter.criticalInstants->at(2) in
                  Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->excluding(iter.criticalInstant), criticalInstant:Integer = nextCriticalInstant, i1:Integer = 1, i2:Integer = 1}
                endif
              else
                Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1}
              endif
            else
              Tuple{flag:Boolean = false, criticalInstants:Sequence(Integer) = Sequence{}, criticalInstant:Integer = null, i1:Integer = null, i2:Integer = null}
            endif
          endif
        else
          Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1}
        endif
      endif
    else
      if iter.criticalInstants->notEmpty() and elem.timestamp.value >= iter.criticalInstant then
        if elem.timestamp.value = iter.criticalInstant then
          if e = firstEffect then
            Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = 2}
          else
            Tuple{flag:Boolean = false, criticalInstants:Sequence(Integer) = Sequence{}, criticalInstant:Integer = null, i1:Integer = null, i2:Integer = null}
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) then
            if iter.i2 = effectSize then
              if iter.criticalInstants->size() = 1 then
                Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->excluding(iter.criticalInstant), criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = 1}
              else
                let nextCriticalInstant:Integer = iter.criticalInstants->at(2) in
                Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->excluding(iter.criticalInstant), criticalInstant:Integer = nextCriticalInstant, i1:Integer = 1, i2:Integer = 1}
              endif
            else
              Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = iter.i2 + 1}
            endif
          else
            Tuple{flag:Boolean = false, criticalInstants:Sequence(Integer) = Sequence{}, criticalInstant:Integer = null, i1:Integer = null, i2:Integer = null}
          endif
        endif
      else
        Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = 1}
      endif
    endif
  else
    iter
  endif
).criticalInstants->isEmpty()

-- modified on 28/05/2015
def: checkPatternResponseManyManyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:oclr::TimeDistance, effects:Sequence(String)):Boolean =
let value:Integer = distance.value, which:oclr::ComparingOperator = distance.comparingOperator in
if which = oclr::ComparingOperator::ATLEAST then
  self.checkPatternResponseManyManyAtLeastMid(subtrace, causes, value, effects)
else
  if which = oclr::ComparingOperator::ATMOST then
    self.checkPatternResponseManyManyAtMostMid(subtrace, causes, value, effects)
  else
    self.checkPatternResponseManyManyExactlyMid(subtrace, causes, value, effects)
  endif
endif

-- modified on 07/06/2015
def: checkPatternResponseOneManyRight(subtrace:OrderedSet(trace::TraceElement), cause:String, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let effectSize:Integer = effects->size() in
subtrace->iterate(
  elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, effectCriticalInstant:Integer, i2:Integer) = Tuple{flag:Boolean = true, effectCriticalInstant:Integer = 0, i2:Integer = 1} |
  let e:String = elem.event.name in
  if e = cause then
    Tuple{flag:Boolean = false, effectCriticalInstant:Integer = iter.effectCriticalInstant, i2:Integer = 1}
  else
    if not iter.flag then
      let t:Integer = elem.timestamp.value in
      if e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = true, effectCriticalInstant:Integer = iter.effectCriticalInstant, i2:Integer = 1}
        else
          let i:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, effectCriticalInstant:Integer = t + effectDistances->at(i).value, i2:Integer = i}
        endif
      else
        Tuple{flag:Boolean = iter.flag, effectCriticalInstant:Integer = iter.effectCriticalInstant, i2:Integer = 1}
      endif
    else
      iter
    endif
  endif
).flag

-- modified on 10/06/2015
def: checkPatternResponseManyManyRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size() 
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, i1:Integer, i2:Integer, effectCriticalInstant:Integer) = Tuple{flag:Boolean = true, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  let e:String = elem.event.name, cause:String = causes->at(iter.i1), effect:String = effects->at(iter.i2) in
  if e = cause  then
    if iter.i1 = causeSize then
      Tuple{flag:Boolean = false, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
    else
      if e = effect and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = true, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          let i:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, i2:Integer = i, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i).value}
        endif
      else
        Tuple{flag:Boolean = iter.flag, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    endif
  else
    if not iter.flag and e = effect and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
      if iter.i2 = effectSize then
        Tuple{flag:Boolean = true, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        let i:Integer = iter.i2 + 1 in
        Tuple{flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = i, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i).value}
      endif
    else
      Tuple{flag:Boolean = iter.flag, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
    endif
  endif
).flag

--modified on 10/06/2015
def: checkPatternResponseOneManyAtLeastMidRight(subtrace:OrderedSet(trace::TraceElement), cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer) = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0} |
  let e:String = elem.event.name in
  if e = cause then -- latest cause
    Tuple{flag:Boolean = false, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
  else
    if not iter.flag then
      let t:Integer = elem.timestamp.value in
      if iter.i2 = 1 and e = firstEffect then
        if t >= iter.midCriticalInstant then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      else
        if e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = true, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          else
            let i:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    else
      iter
    endif
  endif
).flag

--modified on 10/06/2015
def: checkPatternResponseOneManyAtMostMidRight(subtrace:OrderedSet(trace::TraceElement), cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  let e:String = elem.event.name in
  if iter.flag then
    if iter.midCriticalInstant = 0 then
      if e = cause then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        iter
      endif
    else
--      if elem.timestamp.value > iter.midCriticalInstant then -- early detecting violation
--        Tuple{flag:Boolean = false, midCriticalInstant:Integer = 0, i2:Integer = null, effectCriticalInstant:Integer = null}
--      else
        let t:Integer = elem.timestamp.value in
        if iter.i2 = 1 and e = firstEffect then
          if t <= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = 0, i2:Integer = null, effectCriticalInstant:Integer = null}
          endif
        else
          if e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            else
              let i:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
--      endif
    endif
  else
    iter
  endif
).midCriticalInstant = 0

--modified on 10/06/2015
def: checkPatternResponseOneManyExactlyMidRight(subtrace:OrderedSet(trace::TraceElement), cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), midCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0} |
  if iter.flag then
    let e:String = elem.event.name in
    if e = cause then
      let ct:Integer = elem.timestamp.value + midDistance in
      Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(ct), midCriticalInstant:Integer = ct, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
    else
      let t:Integer = elem.timestamp.value in
      if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
        if t = iter.midCriticalInstant then
          if e = firstEffect then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            if iter.i2 = effectSize then
              if iter.midCriticalInstants->size() = 1 then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              else
                let nextCriticalInstant:Integer = iter.midCriticalInstants->at(2) in
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = nextCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              endif
            else
              let i:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
            endif
          else
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          endif
        endif
      else
        iter
      endif
    endif
  else
    iter
  endif
).midCriticalInstants->isEmpty()

--modified on 10/06/2015
def: checkPatternResponseOneManyMidRight(subtrace:OrderedSet(trace::TraceElement), cause:String, midDistance:oclr::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let midValue:Integer = midDistance.value, midWhich:oclr::ComparingOperator = midDistance.comparingOperator in
if midWhich = oclr::ComparingOperator::ATLEAST then
  self.checkPatternResponseOneManyAtLeastMidRight(subtrace, cause, midValue, effects, effectDistances)
else
  if midWhich = oclr::ComparingOperator::ATMOST then
    self.checkPatternResponseOneManyAtMostMidRight(subtrace, cause, midValue, effects, effectDistances)
  else
    self.checkPatternResponseOneManyExactlyMidRight(subtrace, cause, midValue, effects, effectDistances)
  endif
endif

-- modified on 09/06/2015
def: checkPatternResponseManyManyAtLeastMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = null}
  |
  let e:String = elem.event.name in
  if e = causes->at(iter.i1)  then
    let t:Integer = elem.timestamp.value in
    if iter.i1 = causeSize then
      Tuple{flag:Boolean = false, midCriticalInstant:Integer = t + midDistance, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
    else
      if not iter.flag and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = 1 then
          if t >= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        else
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = true, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          else
            let i:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
          endif
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    endif   
  else
    let t:Integer = elem.timestamp.value in
    if not iter.flag and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
      if iter.i2 = 1 then
        if t >= iter.midCriticalInstant then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = iter.i2, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      else
        if iter.i2 = effectSize then -- until effects->last(), the property is satisfied so far
          Tuple{flag:Boolean = true, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          let i:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
        endif
      endif
    else
      Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
    endif
  endif
).flag

-- modified on 10/06/2015
def: checkPatternResponseManyManyAtMostMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  let e:String = elem.event.name in
  if iter.flag then
    if iter.midCriticalInstant = 0 then
      if e = causes->at(iter.i1) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i1:Integer = 1, i2:Integer = iter.i2, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    else
--      if elem.timestamp.value > iter.midCriticalInstant then -- early detecting violation
--        Tuple{flag:Boolean = false, midCriticalInstant:Integer = 0, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
--      else
        let t:Integer = elem.timestamp.value in
        if iter.i2 = 1 and e = firstEffect then
          if t <= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = 0, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          endif
        else
          if e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = 0, i1:Integer = iter.i1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            else
              let i:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
--      endif
    endif
  else
    iter
  endif
).midCriticalInstant = 0

-- modified on 10/06/2015
def: checkPatternResponseManyManyExactlyMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), midCriticalInstant:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name, t:Integer = elem.timestamp.value in
    if e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        let ct:Integer = t + midDistance in
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(ct), midCriticalInstant:Integer = ct, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        if e = effects->at(iter.i2) and iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          if t = iter.midCriticalInstant then
            if e = firstEffect then
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
            else
              Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = null, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
            endif
          else
            if iter.i2 > 1 then
              if iter.i2 = effectSize then
                if iter.midCriticalInstants->size() = 1 then
                  Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
                else
                  let nextCriticalInstant:Integer = iter.midCriticalInstants->at(2) in
                  Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = nextCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
                endif
              else
                let i:Integer = iter.i2 + 1 in
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
              endif
            else
              Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = null, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
            endif
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    else
      if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
        if t = iter.midCriticalInstant then
          if e = firstEffect then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = null, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            if iter.i2 = effectSize then
              if iter.midCriticalInstants->size() = 1 then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              else
                let nextCriticalInstant:Integer = iter.midCriticalInstants->at(2) in
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = nextCriticalInstant, i1:Integer = iter.i1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              endif
            else
              let i:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1, i2:Integer = i, effectCriticalInstant:Integer = t + effectDistances->at(i).value}
            endif
          else
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = null, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          endif
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    endif
  else
    iter
  endif
).midCriticalInstants->isEmpty()

-- modified on 10/06/2015
def: checkPatternResponseManyManyMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), midDistance:oclr::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let midValue:Integer = midDistance.value, midWhich:oclr::ComparingOperator = midDistance.comparingOperator in
if midWhich = oclr::ComparingOperator::ATLEAST then
  self.checkPatternResponseManyManyAtLeastMidRight(subtrace, causes, midValue, effects, effectDistances)
else
  if midWhich = oclr::ComparingOperator::ATMOST then
    self.checkPatternResponseManyManyAtMostMidRight(subtrace, causes, midValue, effects, effectDistances)
  else
    self.checkPatternResponseManyManyExactlyMidRight(subtrace, causes, midValue, effects, effectDistances)
  endif
endif

-- modified on 10/06/2015
def: checkPatternResponseManyOneLeft(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effect:String):Boolean =
let causeSize:Integer = causes->size() in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, i1:Integer, causeCriticalInstant:Integer) = Tuple{flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = 0}
  |
  let e:String = elem.event.name in
  if e = causes->at(iter.i1) and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
    if iter.i1 = causeSize then
      Tuple{flag:Boolean = false, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
    else
      let i:Integer = iter.i1 + 1 in
      Tuple{flag:Boolean = iter.flag, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i).value}
    endif
  else
    if e = effect then
      Tuple{flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
    else
      Tuple{flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
    endif
  endif
).flag

-- modified on 10/06/2015
def: checkPatternResponseManyManyLeft(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size() 
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer) = Tuple{flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1}
  |
  let e:String = elem.event.name, cause:String = causes->at(iter.i1), effect:String = effects->at(iter.i2) in
  if e = cause and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
    if iter.i1 = causeSize then
      Tuple{flag:Boolean = false, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
    else
      if e = effect then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
        else
          let i:Integer = iter.i1 + 1 in
          Tuple{flag:Boolean = iter.flag, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i).value, i2:Integer = iter.i2 + 1}
        endif
      else
        let i:Integer = iter.i1 + 1 in
        Tuple{flag:Boolean = iter.flag, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i).value, i2:Integer = 1}
      endif
    endif
  else
    if not iter.flag and e = effect then
      if iter.i2 = effectSize then
        Tuple{flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
      else
        Tuple{flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1}
      endif
    else
      Tuple{flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
    endif
  endif
).flag

-- modified on 10/06/2015
def: checkPatternResponseManyOneLeftAtLeastMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String):Boolean =
let causeSize:Integer = causes->size() in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer) = Tuple{midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0}
  |
  let e:String = elem.event.name, t:Integer = elem.timestamp.value in
  if e = causes->at(iter.i1) and self.compare(t, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
    if iter.i1 = causeSize then
      Tuple{midCriticalInstant:Integer = t + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
    else
      let i:Integer = iter.i1 + 1 in
      Tuple{midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = t + causeDistances->at(i).value}
    endif
  else
    if e = effect and t >= iter.midCriticalInstant then
      Tuple{midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
    else
      Tuple{midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
    endif
  endif
).midCriticalInstant = 0

-- modified on 10/06/2015
def: checkPatternResponseManyOneLeftAtMostMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String):Boolean =
let causeSize:Integer = causes->size() in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0}
  |
  let e:String = elem.event.name in
  if iter.flag then
    if iter.midCriticalInstant = 0 then
      let t:Integer = elem.timestamp.value in
      if e = causes->at(iter.i1) and self.compare(t, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = t + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
        else
          let i:Integer = iter.i1 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = t + causeDistances->at(i).value}
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      endif
    else
--      if elem.timestamp.value > iter.midCriticalInstant then -- early detecting violation
--        Tuple{flag:Boolean = false, midCriticalInstant:Integer = 0, i1:Integer = null, causeCriticalInstant:Integer = null}
--      else
      if e = effect then
        if elem.timestamp.value <= iter.midCriticalInstant then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
        else
          Tuple{flag:Boolean = false, midCriticalInstant:Integer = 0, i1:Integer = null, causeCriticalInstant:Integer = null}
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      endif
--      endif
    endif
  else
    iter
  endif
).midCriticalInstant = 0

-- modified on 10/06/2015
def: checkPatternResponseManyOneLeftExactlyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String):Boolean =
let causeSize:Integer = causes->size() in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name, t:Integer = elem.timestamp.value in
    if e = causes->at(iter.i1) and self.compare(t, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        let ct:Integer = t + midDistance in
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(ct), midCriticalInstant:Integer = ct, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      else
        let i:Integer = iter.i1 + 1 in
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = t + causeDistances->at(i).value}
      endif
    else
      if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
        if t = iter.midCriticalInstant and e = effect then
          if iter.midCriticalInstants->size() = 1 then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
          else
            let nextCriticalInstant:Integer = iter.midCriticalInstants->at(2) in
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = nextCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
          endif
        else
          Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null}
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      endif
    endif
  else
    iter
  endif
).midCriticalInstants->isEmpty()

-- modified on 10/06/2015
def: checkPatternResponseManyOneLeftMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:oclr::TimeDistance, effect:String):Boolean =
let midValue:Integer = midDistance.value, midWhich:oclr::ComparingOperator = midDistance.comparingOperator in
if midWhich = oclr::ComparingOperator::ATLEAST then
  self.checkPatternResponseManyOneLeftAtLeastMid(subtrace, causes, causeDistances, midValue, effect)
else
  if midWhich = oclr::ComparingOperator::ATMOST then
    self.checkPatternResponseManyOneLeftAtMostMid(subtrace, causes, causeDistances, midValue, effect)
  else
    self.checkPatternResponseManyOneLeftExactlyMid(subtrace, causes, causeDistances, midValue, effect)
  endif
endif

-- modified on 10/06/2015
def: checkPatternResponseManyManyLeftAtLeastMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1}
  |
  let e:String = elem.event.name, cause:String = causes->at(iter.i1) in
  if e = cause and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
    if iter.i1 = causeSize then
      Tuple{flag:Boolean = false, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
    else
      if not iter.flag and e = effects->at(iter.i2)  then
        if iter.i2 = 1 then
          let i:Integer = iter.i1 + 1 in
          if elem.timestamp.value >= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i).value, i2:Integer = 2}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i).value, i2:Integer = iter.i2}
          endif
        else
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = true, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
          else
            let i:Integer = iter.i1 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i).value, i2:Integer = iter.i2 + 1}
          endif
        endif
      else
        let i:Integer = iter.i1 + 1 in
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i).value, i2:Integer = 1}
      endif
    endif
  else
    if not iter.flag and e = effects->at(iter.i2) then
      if iter.i2 = 1 then
        if elem.timestamp.value >= iter.midCriticalInstant then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2}
        endif
      else
        if iter.i2 = effectSize then -- until effects->last(), the property is satisfied so far
          Tuple{flag:Boolean = true, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1}
        endif
      endif
    else
      Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
    endif
  endif
).flag

-- modified on 10/06/2015
def: checkPatternResponseManyManyLeftAtMostMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1} |
  let e:String = elem.event.name in
  if iter.flag then
    if iter.midCriticalInstant = 0 then
      if e = causes->at(iter.i1) and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2}
        else
          let i:Integer = iter.i1 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i).value, i2:Integer = 1}
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
      endif
    else
--      if elem.timestamp.value > iter.midCriticalInstant then -- early detecting violation
--        Tuple{flag:Boolean = false, midCriticalInstant:Integer = 0, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
--      else
        if iter.i2 = 1 and e = firstEffect then
          if elem.timestamp.value <= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2}
          else
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = 0, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
          endif
        else
          if e = effects->at(iter.i2) then
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1}
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
          endif
        endif
--      endif
    endif
  else
    iter
  endif
).midCriticalInstant = 0

-- modified on 09/06/2015
def: checkPatternResponseManyManyLeftExactlyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1} |
  if iter.flag then
    let e:String = elem.event.name, t:Integer = elem.timestamp.value, cause:String = causes->at(iter.i1), effect:String = effects->at(iter.i2) in
    if e = cause and self.compare(t, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        let ct:Integer = t + midDistance in
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(ct), midCriticalInstant:Integer = ct, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
      else
        if e = effect and iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
          if t = iter.midCriticalInstant then
            if e = firstEffect then
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2}
            else
              Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
            endif
          else
            if iter.i2 > 1 then
              if iter.i2 = effectSize then
                if iter.midCriticalInstants->size() = 1 then
                  Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
                else
                  let nextCriticalInstant:Integer = iter.midCriticalInstants->at(2) in
                  Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = nextCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
                endif
              else
                let i:Integer = iter.i1 + 1 in
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i).value, i2:Integer = iter.i2 + 1}
              endif
            else
              Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
            endif
          endif
        else
          let i:Integer = iter.i1 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i).value, i2:Integer = 1}
        endif
      endif
    else
      if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
        if t = iter.midCriticalInstant then
          if e = firstEffect then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2}
          else
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
          endif
        else
          if iter.i2 > 1 and e = effect then
            if iter.i2 = effectSize then
              if iter.midCriticalInstants->size() = 1 then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
              else
                let nextCriticalInstant:Integer = iter.midCriticalInstants->at(2) in
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = nextCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
              endif
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1}
            endif
          else
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
          endif
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
      endif
    endif
  else
    iter
  endif
).midCriticalInstants->isEmpty()

-- modified on 10/06/2015
def: checkPatternResponseManyManyLeftMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:oclr::TimeDistance, effects:Sequence(String)):Boolean =
let midValue:Integer = midDistance.value, midWhich:oclr::ComparingOperator = midDistance.comparingOperator in
if midWhich = oclr::ComparingOperator::ATLEAST then
  self.checkPatternResponseManyManyLeftAtLeastMid(subtrace, causes, causeDistances, midValue, effects)
else
  if midWhich = oclr::ComparingOperator::ATMOST then
    self.checkPatternResponseManyManyLeftAtMostMid(subtrace, causes, causeDistances, midValue, effects)
  else
    self.checkPatternResponseManyManyLeftExactlyMid(subtrace, causes, causeDistances, midValue, effects)
  endif
endif

-- modified on 10/06/2015
def: checkPatternResponseManyManyLeftRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size() 
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer) = Tuple{flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  let e:String = elem.event.name, cause:String = causes->at(iter.i1), effect:String = effects->at(iter.i2) in
  if e = cause and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
    if iter.i1 = causeSize then
      Tuple{flag:Boolean = false, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
    else
      if e = effect and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          let i11:Integer = iter.i1 + 1, i22:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i22).value}
        endif
      else
        let i11:Integer = iter.i1 + 1 in
        Tuple{flag:Boolean = iter.flag, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    endif
  else
    if not iter.flag and e = effect and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
      if iter.i2 = effectSize then
        Tuple{flag:Boolean = true, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        let i22:Integer = iter.i2 + 1 in
        Tuple{flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
      endif
    else
      Tuple{flag:Boolean = iter.flag, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
    endif
  endif
).flag


-- modified on 10/06/2015
def: checkPatternResponseManyManyLeftAtLeastMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  let e:String = elem.event.name, cause:String = causes->at(iter.i1) in
  if e = cause and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
    if iter.i1 = causeSize then
      Tuple{flag:Boolean = false, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
    else
      if not iter.flag and e = effects->at(iter.i2)  then
        if iter.i2 = 1 then
          let i:Integer = iter.i1 + 1 in
          if elem.timestamp.value >= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i).value, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp.value + secondEffectDistance}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i).value, i2:Integer = iter.i2, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        else
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = true, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          else
            let i11:Integer = iter.i1 + 1, i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i22).value}
          endif
        endif
      else
        let i11:Integer = iter.i1 + 1 in
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    endif
  else
    if not iter.flag and e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
      if iter.i2 = 1 then
        if elem.timestamp.value >= iter.midCriticalInstant then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp.value + secondEffectDistance}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      else
        if iter.i2 = effectSize then -- until effects->last(), the property is satisfied so far
          Tuple{flag:Boolean = true, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          let i22:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i22).value}
        endif
      endif
    else
      Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
    endif
  endif
).flag

-- modified on 10/06/2015
def: checkPatternResponseManyManyLeftAtMostMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  let e:String = elem.event.name in
  if iter.flag then
    if iter.midCriticalInstant = 0 then
      if e = causes->at(iter.i1) and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
        if iter.i1 = causeSize then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          let i11:Integer = iter.i1 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    else
--      if elem.timestamp.value > iter.midCriticalInstant then -- early detecting violation
--        Tuple{flag:Boolean = false, midCriticalInstant:Integer = 0, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
--      else
        if iter.i2 = 1 and e = firstEffect then
          if elem.timestamp.value <= iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(2).value}
          else
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = 0, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          endif
        else
          if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            else
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
            endif
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        endif
--      endif
    endif
  else
    iter
  endif
).midCriticalInstant = 0

-- modified on 10/06/2015
def: checkPatternResponseManyManyLeftExactlyMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name, t:Integer = elem.timestamp.value in
    if e = causes->at(iter.i1) and self.compare(t, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        let ct:Integer = t + midDistance in
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(ct), midCriticalInstant:Integer = ct, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        if e = effects->at(iter.i2) and iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          if t = iter.midCriticalInstant then
            if e = firstEffect then
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
            else
              Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
            endif
          else
            if iter.i2 > 1 then
              if iter.i2 = effectSize then
                if iter.midCriticalInstants->size() = 1 then
                  Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
                else
                  let nextCriticalInstant:Integer = iter.midCriticalInstants->at(2) in
                  Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = nextCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
                endif
              else
                let i11:Integer = iter.i1 + 1, i22:Integer = iter.i2 + 1 in
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = t + effectDistances->at(i22).value}
              endif
            else
              Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
            endif
          endif
        else
          let i11:Integer = iter.i1 + 1 in
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = t + causeDistances->at(i11).value, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    else
      if iter.midCriticalInstants->notEmpty() and t >= iter.midCriticalInstant then
        if t = iter.midCriticalInstant then
          if e = firstEffect then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          endif
        else
          if iter.i2 > 1 and e = effects->at(iter.i2) and self.compare(t, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
            if iter.i2 = effectSize then
              if iter.midCriticalInstants->size() = 1 then
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              else
                let nextCriticalInstant:Integer = iter.midCriticalInstants->at(2) in
                Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->excluding(iter.midCriticalInstant), midCriticalInstant:Integer = nextCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
              endif
            else
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = t + effectDistances->at(i22).value}
            endif
          else
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = Sequence{}, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          endif
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    endif
  else
    iter
  endif
).midCriticalInstants->isEmpty()

-- modified on 10/06/2015
def: checkPatternResponseManyManyLeftMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:oclr::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let midValue:Integer = midDistance.value, midWhich:oclr::ComparingOperator = midDistance.comparingOperator in
if midWhich = oclr::ComparingOperator::ATLEAST then
  self.checkPatternResponseManyManyLeftAtLeastMidRight(subtrace, causes, causeDistances, midValue, effects, effectDistances)
else
  if midWhich = oclr::ComparingOperator::ATMOST then
    self.checkPatternResponseManyManyLeftAtMostMidRight(subtrace, causes, causeDistances, midValue, effects, effectDistances)
  else
    self.checkPatternResponseManyManyLeftExactlyMidRight(subtrace, causes, causeDistances, midValue, effects, effectDistances)
  endif
endif

def: checkPatternResponse(subtrace:OrderedSet(trace::TraceElement), pattern:oclr::Pattern):Boolean =
--check the satisfiability of the response pattern 'effect responding cause'
--in the first event in the chain 'effect', it may contains time distance to the last event in the chain 'cause'
if subtrace->isEmpty() then
  true
else
  let orderPattern:oclr::OrderPattern = pattern.oclAsType(oclr::OrderPattern),
      causes:Sequence(String) = orderPattern.block2.event.name,
      causeDistances:Sequence(Tuple(which:Integer, value:Integer)) = self.loadDistances(orderPattern.block2.timeDistance),
      causeSize:Integer = causes->size(),
      effects:Sequence(String) = orderPattern.block1.event.name,
      effectDistances:Sequence(Tuple(which:Integer, value:Integer)) = self.loadDistances(orderPattern.block1.timeDistance),
      effectSize:Integer = effects->size()
  in
  if causeDistances->isEmpty() then
    if effectDistances->isEmpty() then
      if orderPattern.timeDistance->isEmpty() then
        if causeSize = 1 then
          let cause:String = causes->first() in
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.checkPatternResponseOneOnePlain(subtrace, cause, effect)
          else
            self.checkPatternResponseOneManyPlain(subtrace, cause, effects)
          endif
        else
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.checkPatternResponseManyOnePlain(subtrace, causes, effect)
          else
            self.checkPatternResponseManyManyPlain(subtrace, causes, effects)
          endif
        endif
      else
        if causeSize = 1 then
          let cause:String = causes->first() in
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.checkPatternResponseOneOneMid(subtrace, cause, orderPattern.timeDistance, effect)
          else
            self.checkPatternResponseOneManyMid(subtrace, cause, orderPattern.timeDistance, effects)
          endif
        else
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.checkPatternResponseManyOneMid(subtrace, causes, orderPattern.timeDistance, effect)
          else
            self.checkPatternResponseManyManyMid(subtrace, causes, orderPattern.timeDistance, effects)
          endif
        endif
      endif
    else
      if orderPattern.timeDistance->isEmpty() then
        if causeSize = 1 then
          let cause:String = causes->first() in
          self.checkPatternResponseOneManyRight(subtrace, cause, effects, effectDistances)
        else
          self.checkPatternResponseManyManyRight(subtrace, causes, effects, effectDistances)
        endif
      else
        if causeSize = 1 then
          let cause:String = causes->first() in
          self.checkPatternResponseOneManyMidRight(subtrace, cause, orderPattern.timeDistance, effects, effectDistances)
        else
          self.checkPatternResponseManyManyMidRight(subtrace, causes, orderPattern.timeDistance, effects, effectDistances)
        endif
      endif
    endif
  else
    if effectDistances->isEmpty() then
      if orderPattern.timeDistance->isEmpty() then
        if effectSize = 1 then
          let effect:String = effects->first() in
          self.checkPatternResponseManyOneLeft(subtrace, causes, causeDistances, effect)
        else
          self.checkPatternResponseManyManyLeft(subtrace, causes, causeDistances, effects)
        endif
      else
        if effectSize = 1 then
          let effect:String = effects->first() in
          self.checkPatternResponseManyOneLeftMid(subtrace, causes, causeDistances, orderPattern.timeDistance, effect)
        else
          self.checkPatternResponseManyManyLeftMid(subtrace, causes, causeDistances, orderPattern.timeDistance, effects)
        endif
      endif
    else
      if orderPattern.timeDistance->isEmpty() then
        self.checkPatternResponseManyManyLeftRight(subtrace, causes, causeDistances, effects, effectDistances)
      else
        self.checkPatternResponseManyManyLeftMidRight(subtrace, causes, causeDistances, orderPattern.timeDistance, effects, effectDistances)
      endif
    endif
  endif
endif

--modified on 11/06/2015
def: checkPatternPrecedenceOneOnePlain(subtrace:OrderedSet(trace::TraceElement), cause:String, effect:String):Boolean =
--"cause preceding effect"
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, result:Integer) = Tuple{flag:Boolean = true, result:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = cause then
      Tuple{flag:Boolean = false, result:Integer = -1}
    else
      if e = effect then
        Tuple{flag:Boolean = false, result:Integer = -2} -- violation
      else
        iter
      endif
    endif
  else
    iter
  endif
).result >= -1

-- modified on 11/06/2015
def: checkPatternPrecedenceOneOneAtLeastMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effect:String):Boolean =
--"cause preceding at least distance tu effect"
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, criticalInstant:Integer) = Tuple{flag:Boolean = true, criticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if iter.criticalInstant = 0 and e = cause then --catch the first occurrence of cause
      Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = elem.timestamp.value + distance}
    else
      if e = effect then
        if iter.criticalInstant = 0 or elem.timestamp.value < iter.criticalInstant then
          Tuple{flag:Boolean = false, criticalInstant:Integer = -2} -- violation
        else
          Tuple{flag:Boolean = false, criticalInstant:Integer = -1}
        endif
      else
        iter
      endif
    endif
  else
    iter
  endif
).criticalInstant >= -1

-- modified on 11/06/2015
def: checkPatternPrecedenceOneOneAtMostMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effect:String):Boolean =
--"cause preceding at most distance tu effect"
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, criticalInstant:Integer) = Tuple{flag:Boolean = true, criticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = cause then --latest cause
      Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = elem.timestamp.value + distance}
    else
      if e = effect and elem.timestamp.value > iter.criticalInstant then
        Tuple{flag:Boolean = false, criticalInstant:Integer = null} -- violation
      else
        iter
      endif
    endif
  else
    iter
  endif
).flag

-- modified on 21/04/2015
def: checkPatternPrecedenceOneOneExactlyMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effect:String):Boolean =
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, criticalInstants:Sequence(Integer)) = Tuple{flag:Boolean = true, criticalInstants:Sequence(Integer) = Sequence{}} |
  if iter.flag then
    let e:String = elem.event.name in
    if e = cause then
      Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->append(elem.timestamp.value+distance)}
    else
      if e = effect then
        let t:Integer = elem.timestamp.value in
        if iter.criticalInstants->includes(t) then
          Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->select(subElem | subElem > t)}
        else
          Tuple{flag:Boolean = false, criticalInstants:Sequence(Integer) = null}
        endif
      else
        iter
      endif
    endif
  else
    iter
  endif
).flag

-- modified on 15/04/2015
def: checkPatternPrecedenceOneOneMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:oclr::TimeDistance, effect:String):Boolean =
let value:Integer = distance.value, which:oclr::ComparingOperator = distance.comparingOperator in
if which = oclr::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceOneOneAtLeastMid(subtrace, cause, value, effect)
else
  if which = oclr::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceOneOneAtMostMid(subtrace, cause, value, effect)
  else
    self.checkPatternPrecedenceOneOneExactlyMid(subtrace, cause, value, effect)
  endif
endif

-- modified on 11/06/2015
def: checkPatternPrecedenceOneManyPlain(subtrace:OrderedSet(trace::TraceElement), cause:String, effects:Sequence(String)):Boolean =
let effectSize:Integer = effects->size() in
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, result:Integer, i2:Integer) = Tuple{flag:Boolean = true, result:Integer = 0, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = cause then --catch the first occurrence of cause
      Tuple{flag:Boolean = false, result:Integer = -1, i2:Integer = null}
    else
      if e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = false, result:Integer = -2, i2:Integer = null}
        else
          Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i2:Integer = iter.i2 + 1}
        endif
      else
        Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i2:Integer = 1}
      endif
    endif
  else
    iter
  endif
).result >= -1

-- modified on 11/06/2015
def: checkPatternPrecedenceOneManyAtLeastMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effects:Sequence(String)):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, criticalInstant:Integer, i2:Integer) = Tuple{flag:Boolean = true, criticalInstant:Integer = 0, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if iter.criticalInstant = 0 and e = cause then --catch the first occurrence of cause
      Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = elem.timestamp.value + distance, i2:Integer = 1}
    else
      if iter.i2 = 1 and e = firstEffect then
        if iter.criticalInstant = 0 or elem.timestamp.value < iter.criticalInstant then
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i2:Integer = 2}
        else
          Tuple{flag:Boolean = false, criticalInstant:Integer = -1, i2:Integer = null}
        endif
      else
        if e = effects->at(iter.i2) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, criticalInstant:Integer = -2, i2:Integer = null}
          else
            Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i2:Integer = iter.i2 + 1}
          endif
        else
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i2:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).criticalInstant >= -1

-- modified on 11/06/2015
def: checkPatternPrecedenceOneManyAtMostMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effects:Sequence(String)):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstant:Integer, i2:Integer) = Tuple{flag:Boolean = true, criticalInstant:Integer = 0, i2:Integer = 1} |
  let e:String = elem.event.name in
  if iter.flag then
    if e = cause then
      Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = elem.timestamp.value + distance, i2:Integer = 1}
    else
      if iter.i2 = 1 and e = firstEffect then -- iter.i2 = 1 is necessary for the case effects has two identical events in the chain, e.g., "aba"
        if elem.timestamp.value > iter.criticalInstant then
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i2:Integer = 2}
        else
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i2:Integer = 1}
        endif
      else
        if e = effects->at(iter.i2) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, criticalInstant:Integer = null, i2:Integer = null}
          else
            Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i2:Integer = iter.i2 + 1}
          endif
        else
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i2:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).flag

-- modified on 11/06/2015
def: checkPatternPrecedenceOneManyExactlyMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:Integer, effects:Sequence(String)):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, criticalInstants:Sequence(Integer), i2:Integer) = Tuple{flag:Boolean = true, criticalInstants:Sequence(Integer) = Sequence{}, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = cause then
      Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->append(elem.timestamp.value+distance), i2:Integer = 1}
    else
      if iter.i2 = 1 and e = firstEffect then
        let t:Integer = elem.timestamp.value in
        if iter.criticalInstants->includes(t) then
          Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->select(subElem | subElem > t), i2:Integer = 1}
        else
          Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, i2:Integer = 2}
        endif
      else
        if e = effects->at(iter.i2) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, criticalInstants:Sequence(Integer) = null, i2:Integer = null}
          else
            Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, i2:Integer = iter.i2 + 1}
          endif
        else
          Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, i2:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).flag

-- modified on 22/04/2015
def: checkPatternPrecedenceOneManyMid(subtrace:OrderedSet(trace::TraceElement), cause:String, distance:oclr::TimeDistance, effects:Sequence(String)):Boolean =
let value:Integer = distance.value, which:oclr::ComparingOperator = distance.comparingOperator in
if which = oclr::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceOneManyAtLeastMid(subtrace, cause, value, effects)
else
  if which = oclr::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceOneManyAtMostMid(subtrace, cause, value, effects)
  else
    self.checkPatternPrecedenceOneManyExactlyMid(subtrace, cause, value, effects)
  endif
endif


--modified on 11/06/2015
def: checkPatternPrecedenceOneManyRight(subtrace:OrderedSet(trace::TraceElement), cause:String, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, result:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, result:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = cause then
      Tuple{flag:Boolean = false, result:Integer = -1, i2:Integer = null, effectCriticalInstant:Integer = null}
    else
      if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = false, result:Integer = -2, i2:Integer = null, effectCriticalInstant:Integer = null}
        else
          let i22:Integer = iter.i2 + 1 in
          Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
        endif
      else
        Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    endif
  else
    iter
  endif
).result >= -1

--modified on 11/06/2015
def: checkPatternPrecedenceOneManyAtLeastMidRight(subtrace:OrderedSet(trace::TraceElement), cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if iter.midCriticalInstant = 0 and e = cause then --catch the first occurrence of cause
      Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
    else
      if iter.i2 = 1 and e = firstEffect then
        let t:Integer = elem.timestamp.value in
        if iter.midCriticalInstant = 0 or t < iter.midCriticalInstant then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
        else
          Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i2:Integer = null, effectCriticalInstant:Integer = null}
        endif
      else
        if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2, i2:Integer = null, effectCriticalInstant:Integer = null}
          else
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstant >= -1

--modified on 11/06/2015
def: checkPatternPrecedenceOneManyAtMostMidRight(subtrace:OrderedSet(trace::TraceElement), cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  let e:String = elem.event.name in
  if iter.flag then
    if e = cause then
      Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
    else
      if iter.i2 = 1 and e = firstEffect then -- iter.i2 = 1 is necessary for the case effects has two identical events in the chain, e.g., "aba"
        let t:Integer = elem.timestamp.value in
        if t > iter.midCriticalInstant then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      else
        if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          else
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    endif
  else
    iter
  endif
).flag

-- added on 22/04/2015
def: checkPatternPrecedenceOneManyExactlyMidRight(subtrace:OrderedSet(trace::TraceElement), cause:String, midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = cause then
      Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(elem.timestamp.value+midDistance), i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
    else
      if iter.i2 = 1 and e = firstEffect then
        let t:Integer = elem.timestamp.value in
        if iter.midCriticalInstants->includes(t) then
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
        endif
      else
        if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          else
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    endif
  else
    iter
  endif
).flag

-- modified on 22/04/2015
def: checkPatternPrecedenceOneManyMidRight(subtrace:OrderedSet(trace::TraceElement), cause:String, midDistance:oclr::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let midValue:Integer = midDistance.value, midWhich:oclr::ComparingOperator=midDistance.comparingOperator in
if midWhich = oclr::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceOneManyAtLeastMidRight(subtrace, cause, midValue, effects, effectDistances)
else
  if midWhich = oclr::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceOneManyAtMostMidRight(subtrace, cause, midValue, effects, effectDistances)
  else
    self.checkPatternPrecedenceOneManyExactlyMidRight(subtrace, cause, midValue, effects, effectDistances)
  endif
endif

-- modified on 11/06/2015
def: checkPatternPrecedenceManyOnePlain(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), effect:String):Boolean =
let causeSize:Integer = causes->size() in
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, result:Integer, i1:Integer) = Tuple{flag:Boolean = true, result:Integer = 0, i1:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = false, result:Integer = -1, i1:Integer = null}
      else
        Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = iter.i1 + 1}
      endif
    else
      if e = effect then
        Tuple{flag:Boolean = false, result:Integer = -2, i1:Integer = null}
      else
        Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1}
      endif
    endif
  else
    iter
  endif
).result >= -1

--modified on 11/06/2015
def: checkPatternPrecedenceManyOneAtLeastMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effect:String):Boolean =
let causeSize:Integer = causes->size() in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstant:Integer, i1:Integer) = Tuple{flag:Boolean = true, criticalInstant:Integer = 0, i1:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if iter.criticalInstant = 0 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = elem.timestamp.value + distance, i1:Integer = 1}
      else
        Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1}
      endif
    else
      if e = effect then
        if iter.criticalInstant = 0 or elem.timestamp.value < iter.criticalInstant then
          Tuple{flag:Boolean = false, criticalInstant:Integer = -2, i1:Integer = null}
        else
          Tuple{flag:Boolean = false, criticalInstant:Integer = -1, i1:Integer = null}
        endif
      else
        Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1}
      endif
    endif
  else
    iter
  endif
).criticalInstant >= -1

--modified on 11/06/2015
def: checkPatternPrecedenceManyOneAtMostMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effect:String):Boolean =
let causeSize:Integer = causes->size() in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstant:Integer, i1:Integer) = Tuple{flag:Boolean = true, criticalInstant:Integer = 0, i1:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = elem.timestamp.value + distance, i1:Integer = 1}
      else
        Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1}
      endif
    else
      if e = effect and elem.timestamp.value > iter.criticalInstant then
        Tuple{flag:Boolean = false, criticalInstant:Integer = null, i1:Integer = null}
      else
        Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1}
      endif
    endif
  else
    iter
  endif
).flag

--modified on 11/06/2015
def: checkPatternPrecedenceManyOneExactlyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effect:String):Boolean =
let causeSize:Integer = causes->size() in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstants:Sequence(Integer), i1:Integer)
  = Tuple{flag:Boolean = true, criticalInstants:Sequence(Integer) = Sequence{}, i1:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->append(elem.timestamp.value+distance), i1:Integer = 1}
      else
        Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, i1:Integer = iter.i1 + 1}
      endif
    else
      if e = effect then
        let t:Integer = elem.timestamp.value in
        if iter.criticalInstants->includes(t) then
          Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->select(subElem | subElem > t), i1:Integer = 1}
        else
          Tuple{flag:Boolean = false, criticalInstants:Sequence(Integer) = null, i1:Integer = null}
        endif
      else
        Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, i1:Integer = 1}
      endif
    endif
  else
    iter
  endif
).flag

-- modified on 11/06/2015
def: checkPatternPrecedenceManyOneMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:oclr::TimeDistance, effect:String):Boolean =
let value:Integer = distance.value, which:oclr::ComparingOperator=distance.comparingOperator in
if which = oclr::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceManyOneAtLeastMid(subtrace, causes, value, effect)
else
  if which = oclr::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceManyOneAtMostMid(subtrace, causes, value, effect)
  else
    self.checkPatternPrecedenceManyOneExactlyMid(subtrace, causes, value, effect)
  endif
endif

-- modified on 11/06/2015
def: checkPatternPrecedenceManyOneLeft(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effect:String):Boolean =
let causeSize:Integer = causes->size() in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, result:Integer, i1:Integer, causeCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, result:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = false, result:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null}
      else
        let i11:Integer = iter.i1 + 1 in
        Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value}
      endif
    else
      if e = effect then
        Tuple{flag:Boolean = false, result:Integer = -2, i1:Integer = null, causeCriticalInstant:Integer = null}
      else
        Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      endif
    endif
  else
    iter
  endif
).result >= -1

--modified on 11/06/2015
def: checkPatternPrecedenceManyOneLeftAtLeastMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String):Boolean =
let causeSize:Integer = causes->size() in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if iter.midCriticalInstant = 0 and e = causes->at(iter.i1) and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      else
        let i11:Integer = iter.i1 + 1 in
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value}
      endif
    else
      if e = effect then
        if iter.midCriticalInstant = 0 or elem.timestamp.value < iter.midCriticalInstant then
          Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2, i1:Integer = null, causeCriticalInstant:Integer = null}
        else
          Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null}
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      endif
    endif
  else
    iter
  endif
).midCriticalInstant >= -1

--modified on 11/06/2015
def: checkPatternPrecedenceManyOneLeftAtMostMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String):Boolean =
let causeSize:Integer = causes->size() in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      else
        let i11:Integer = iter.i1 + 1 in
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value}
      endif
    else
      if e = effect and elem.timestamp.value > iter.midCriticalInstant then
        Tuple{flag:Boolean = false, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null}
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      endif
    endif
  else
    iter
  endif
).flag

--modified on 11/06/2015
def: checkPatternPrecedenceManyOneLeftExactlyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effect:String):Boolean =
let causeSize:Integer = causes->size() in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), i1:Integer, causeCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, i1:Integer = 1, causeCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(elem.timestamp.value+midDistance), i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      else
        let i11:Integer = iter.i1 + 1 in
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value}
      endif
    else
      if e = effect then
        let t:Integer = elem.timestamp.value in
        if iter.midCriticalInstants->includes(t) then
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
        else
          Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null, i1:Integer = null, causeCriticalInstant:Integer = null}
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant}
      endif
    endif
  else
    iter
  endif
).flag

-- modified on 11/06/2015
def: checkPatternPrecedenceManyOneLeftMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:oclr::TimeDistance, effect:String):Boolean =
let midValue:Integer = midDistance.value, midWhich:oclr::ComparingOperator=midDistance.comparingOperator in
if midWhich = oclr::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceManyOneLeftAtLeastMid(subtrace, causes, causeDistances, midValue, effect)
else
  if midWhich = oclr::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceManyOneLeftAtMostMid(subtrace, causes, causeDistances, midValue, effect)
  else
    self.checkPatternPrecedenceManyOneLeftExactlyMid(subtrace, causes, causeDistances, midValue, effect)
  endif
endif

--modified on 11/06/2015
def: checkPatternPrecedenceManyManyPlain(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size()
in
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, result:Integer, i1:Integer, i2:Integer) = Tuple{flag:Boolean = true, result:Integer = 0, i1:Integer = 1, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = false, result:Integer = -1, i1:Integer = null, i2:Integer = null}
      else
        if e = effects->at(iter.i2) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, result:Integer = -2, i1:Integer = null, i2:Integer = null}
          else
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1}
          endif
        else
          Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = iter.i1 + 1, i2:Integer = 1}
        endif
      endif
    else
      if e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = false, result:Integer = -2, i1:Integer = null, i2:Integer = null}
        else
          Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, i2:Integer = iter.i2 + 1}
        endif
      else
        Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, i2:Integer = 1}
      endif
    endif
  else
    iter
  endif
).result >= -1

--modified on 11/06/2015
def: checkPatternPrecedenceManyManyAtLeastMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstant:Integer, i1:Integer, i2:Integer) = Tuple{flag:Boolean = true, criticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1} |
  if iter.flag then
    let e:String = elem.event.name in
    if iter.criticalInstant = 0 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = elem.timestamp.value + distance, i1:Integer = 1, i2:Integer = 1}
      else
        if e = effects->at(iter.i2) then -- for instance {causes: [a,b,c], effects: [d,a,b]}, when i1 = 1, i2 = 2 or i1 = 2, i2 = 3. But it is not possible i1 equals to causeSize, since causes cannot be a sublist of effects.
          if iter.i2 = 1 then
            if iter.criticalInstant = 0 or elem.timestamp.value < iter.criticalInstant then
              Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2} -- a potential violation
            else
              Tuple{flag:Boolean = false, criticalInstant:Integer = -1, i1:Integer = null, i2:Integer = null} -- satisfaction
            endif
          else
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = false, criticalInstant:Integer = -2, i1:Integer = null, i2:Integer = null} -- violation
            else
              Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1}
            endif
          endif
        else
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1}
        endif
      endif
    else
      if iter.i2 = 1 and e = firstEffect then
        if iter.criticalInstant = 0 or elem.timestamp.value < iter.criticalInstant then
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = 2} -- a potential violation
        else
          Tuple{flag:Boolean = false, criticalInstant:Integer = -1, i1:Integer = null, i2:Integer = null} -- satisfaction
        endif
      else
        if e = effects->at(iter.i2) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, criticalInstant:Integer = -2, i1:Integer = null, i2:Integer = null} -- violation
          else
            Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = iter.i2 + 1}
          endif
        else
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).criticalInstant >= -1

--modified on 11/06/2015
def: checkPatternPrecedenceManyManyAtMostMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstant:Integer, i1:Integer, i2:Integer) = Tuple{flag:Boolean = true, criticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = elem.timestamp.value + distance, i1:Integer = 1, i2:Integer = 1}
      else
        if e = effects->at(iter.i2) then
          if iter.i2 = 1 then
            if elem.timestamp.value > iter.criticalInstant then
              Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2}
            else
              Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1}
            endif
          else
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = false, criticalInstant:Integer = null, i1:Integer = null, i2:Integer = null}
            else
              Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1}
            endif
          endif
        else
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1}
        endif
      endif
    else
      if iter.i2 = 1 and e = firstEffect then
        if elem.timestamp.value > iter.criticalInstant then
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = 2}
        else
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = 1}
        endif
      else
        if e = effects->at(iter.i2) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, criticalInstant:Integer = null, i1:Integer = null, i2:Integer = null}
          else
            Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = iter.i2 + 1}
          endif
        else
          Tuple{flag:Boolean = iter.flag, criticalInstant:Integer = iter.criticalInstant, i1:Integer = 1, i2:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).flag

--modified on 11/06/2015
def: checkPatternPrecedenceManyManyExactlyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, criticalInstants:Sequence(Integer), i1:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, criticalInstants:Sequence(Integer) = Sequence{}, i1:Integer = 1, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->append(elem.timestamp.value+distance), i1:Integer = 1, i2:Integer = 1}
      else
        if e = effects->at(iter.i2) then
          if iter.i2 = 1 then
            let t:Integer = elem.timestamp.value in
            if iter.criticalInstants->includes(t) then
              Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->select(subElem | subElem > t), i1:Integer = 1, i2:Integer = 1}
            else
              Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, i1:Integer = iter.i1 + 1, i2:Integer = 2}
            endif
          else
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = false, criticalInstants:Sequence(Integer) = null, i1:Integer = null, i2:Integer = null}
            else
              Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, i1:Integer = iter.i1 + 1, i2:Integer = iter.i2 + 1}
            endif
          endif
        else
          Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, i1:Integer = iter.i1 + 1, i2:Integer = 1}
        endif
      endif
    else
      if iter.i2 = 1 and e = firstEffect then
        let t:Integer = elem.timestamp.value in
        if iter.criticalInstants->includes(t) then
          Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants->select(subElem | subElem > t), i1:Integer = 1, i2:Integer = 1}
        else
          Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, i1:Integer = 1, i2:Integer = 2}
        endif
      else
        if e = effects->at(iter.i2) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, criticalInstants:Sequence(Integer) = null, i1:Integer = null, i2:Integer = null}
          else
            Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, i1:Integer = 1, i2:Integer = iter.i2 + 1}
          endif
        else
          Tuple{flag:Boolean = iter.flag, criticalInstants:Sequence(Integer) = iter.criticalInstants, i1:Integer = 1, i2:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).flag

--modified on 11/06/2015
def: checkPatternPrecedenceManyManyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), distance:oclr::TimeDistance, effects:Sequence(String)):Boolean =
let value:Integer = distance.value, which:oclr::ComparingOperator=distance.comparingOperator in
if which = oclr::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceManyManyAtLeastMid(subtrace, causes, value, effects)
else
  if which = oclr::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceManyManyAtMostMid(subtrace, causes, value, effects)
  else
    self.checkPatternPrecedenceManyManyExactlyMid(subtrace, causes, value, effects)
  endif
endif

def: checkPatternPrecedenceManyManyLeft(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size()
in
subtrace->iterate(elem:trace::TraceElement; iter:Tuple(flag:Boolean, result:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer) = Tuple{flag:Boolean = true, result:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = false, result:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
      else
        if e = effects->at(iter.i2) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, result:Integer = -2, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
          else
            let i11:Integer = iter.i1 + 1 in
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value, i2:Integer = iter.i2 + 1}
          endif
        else
          let i11:Integer = iter.i1 + 1 in
          Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value, i2:Integer = 1}
        endif
      endif
    else
      if e = effects->at(iter.i2) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = false, result:Integer = -2, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
        else
          Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1}
        endif
      else
        Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
      endif
    endif
  else
    iter
  endif
).result >= -1

--modified on 11/06/2015
def: checkPatternPrecedenceManyManyLeftAtLeastMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer) = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1} |
  if iter.flag then
    let e:String = elem.event.name in
    if iter.midCriticalInstant = 0 and e = causes->at(iter.i1) and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
      else
        let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value in
        if e = effects->at(iter.i2) then -- for instance {causes: [a,b,c], effects: [d,a,b]}, when i1 = 1, i2 = 2 or i1 = 2, i2 = 3. But it is not possible i1 equals to causeSize, since causes cannot be a sublist of effects.
          if iter.i2 = 1 then
            if iter.midCriticalInstant = 0 or elem.timestamp.value < iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 2} -- a potential violation
            else
              Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null} -- satisfaction
            endif
          else
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null} -- violation
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = iter.i2 + 1}
            endif
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 1}
        endif
      endif
    else
      if iter.i2 = 1 and e = firstEffect then
        if iter.midCriticalInstant = 0 or elem.timestamp.value < iter.midCriticalInstant then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2} -- a potential violation
        else
          Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null} -- satisfaction
        endif
      else
        if e = effects->at(iter.i2) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null} -- violation
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).midCriticalInstant >= -1

--modified on 11/06/2015
def: checkPatternPrecedenceManyManyLeftAtMostMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1)  and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
      else
        let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value in
        if e = effects->at(iter.i2) then
          if iter.i2 = 1 then
            if elem.timestamp.value > iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 2}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 1}
            endif
          else
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = false, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = iter.i2 + 1}
            endif
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 1}
        endif
      endif
    else
      if iter.i2 = 1 and e = firstEffect then
        if elem.timestamp.value > iter.midCriticalInstant then
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
        endif
      else
        if e = effects->at(iter.i2) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).flag

--modified on 11/06/2015
def: checkPatternPrecedenceManyManyLeftExactlyMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String)):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  firstEffect:String = effects->first()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), i1:Integer, causeCriticalInstant:Integer, i2:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1)  and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(elem.timestamp.value+midDistance), i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
      else
        let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value in
        if e = effects->at(iter.i2) then
          if iter.i2 = 1 then
            let t:Integer = elem.timestamp.value in
            if iter.midCriticalInstants->includes(t) then
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 2}
            endif
          else
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = iter.i2 + 1}
            endif
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 1}
        endif
      endif
    else
      if iter.i2 = 1 and e = firstEffect then
        let t:Integer = elem.timestamp.value in
        if iter.midCriticalInstants->includes(t) then
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2}
        endif
      else
        if e = effects->at(iter.i2) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = iter.i2 + 1}
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1}
        endif
      endif
    endif
  else
    iter
  endif
).flag

--modified on 11/06/2015
def: checkPatternPrecedenceManyManyLeftMid(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:oclr::TimeDistance, effects:Sequence(String)):Boolean =
let midValue:Integer = midDistance.value, midWhich:oclr::ComparingOperator=midDistance.comparingOperator in
if midWhich = oclr::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceManyManyLeftAtLeastMid(subtrace, causes, causeDistances, midValue, effects)
else
  if midWhich = oclr::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceManyManyLeftAtMostMid(subtrace, causes, causeDistances, midValue, effects)
  else
    self.checkPatternPrecedenceManyManyLeftExactlyMid(subtrace, causes, causeDistances, midValue, effects)
  endif
endif

--modified on 12/06/2015
def: checkPatternPrecedenceManyManyRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, result:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, result:Integer = 0, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = false, result:Integer = -1, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
      else
        if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, result:Integer = -2, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          else
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
          endif
        else
          Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    else
      if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = false, result:Integer = -2, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
        else
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
          endif
      else
        Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    endif
  else
    iter
  endif
).result >= -1

--modified on 12/06/2015
def: checkPatternPrecedenceManyManyAtLeastMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if iter.midCriticalInstant = 0 and e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          if iter.i2 = 1 then
            let t:Integer = elem.timestamp.value in
            if iter.midCriticalInstant = 0 or t < iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance} -- a potential violation
            else
              Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null} -- satisfaction
            endif
          else
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null} -- violation
            else
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
            endif
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    else
      if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = 1 then
          let t:Integer = elem.timestamp.value in
          if iter.midCriticalInstant = 0 or t < iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance} -- a potential violation
          else
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null} -- satisfaction
          endif
        else
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null} -- violation
          else
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
          endif
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    endif
  else
    iter
  endif
).midCriticalInstant >= -1

--modified on 12/06/2015
def: checkPatternPrecedenceManyManyAtMostMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          if iter.i2 = 1 then
            let t:Integer = elem.timestamp.value in
            if t > iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          else
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = false, midCriticalInstant:Integer = null, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
            else
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
            endif
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    else
      if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = 1 then
          let t:Integer = elem.timestamp.value in
          if t > iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        else
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = null, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          else
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
          endif
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    endif
  else
    iter
  endif
).flag

--modified on 11/06/2015
def: checkPatternPrecedenceManyManyExactlyMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), i1:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(elem.timestamp.value+midDistance), i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          if iter.i2 = 1 then
            let t:Integer = elem.timestamp.value in
            if iter.midCriticalInstants->includes(t) then
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = iter.i1 + 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
            endif
          else
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
            else
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = iter.i1 + 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
            endif
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = iter.i1 + 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    else
      if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then      
        if iter.i2 = 1 then
          let t:Integer = elem.timestamp.value in
          if iter.midCriticalInstants->includes(t) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          endif
        else
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null, i1:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          else
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
          endif
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    endif
  else
    iter
  endif
).flag

--modified on 12/06/2015
def: checkPatternPrecedenceManyManyMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), midDistance:oclr::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let midValue:Integer = midDistance.value, midWhich:oclr::ComparingOperator=midDistance.comparingOperator in
if midWhich = oclr::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceManyManyAtLeastMidRight(subtrace, causes, midValue, effects, effectDistances)
else
  if midWhich = oclr::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceManyManyAtMostMidRight(subtrace, causes, midValue, effects, effectDistances)
  else
    self.checkPatternPrecedenceManyManyExactlyMidRight(subtrace, causes, midValue, effects, effectDistances)
  endif
endif

def: checkPatternPrecedenceManyManyLeftRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size()
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, result:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, result:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = false, result:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
      else
        if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, result:Integer = -2, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          else
            let i11:Integer = iter.i1 + 1, i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
          endif
        else
          let i11:Integer = iter.i1 + 1 in
          Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = i11, causeCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    else
      if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = effectSize then
          Tuple{flag:Boolean = false, result:Integer = -2, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
        else
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
          endif
      else
        Tuple{flag:Boolean = iter.flag, result:Integer = iter.result, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    endif
  else
    iter
  endif
).result >= -1

--modified on 12/06/2015
def: checkPatternPrecedenceManyManyLeftAtLeastMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if iter.midCriticalInstant = 0 and e = causes->at(iter.i1) and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value in
        if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          if iter.i2 = 1 then
            let t:Integer = elem.timestamp.value in
            if iter.midCriticalInstant = 0 or t < iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance} -- a potential violation
            else
              Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null} -- satisfaction
            endif
          else
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null} -- violation
            else
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
            endif
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    else
      if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = 1 then
          let t:Integer = elem.timestamp.value in
          if iter.midCriticalInstant = 0 or t < iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance} -- a potential violation
          else
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -1, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null} -- satisfaction
          endif
        else
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = -2, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null} -- violation
          else
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
          endif
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    endif
  else
    iter
  endif
).midCriticalInstant >= -1

--modified on 12/06/2015
def: checkPatternPrecedenceManyManyLeftAtMostMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstant:Integer, i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstant:Integer = 0, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = elem.timestamp.value + midDistance, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value in
        if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          if iter.i2 = 1 then
            let t:Integer = elem.timestamp.value in
            if t > iter.midCriticalInstant then
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            endif
          else
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = false, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
            else
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
            endif
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    else
      if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
        if iter.i2 = 1 then
          let t:Integer = elem.timestamp.value in
          if t > iter.midCriticalInstant then
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          endif
        else
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, midCriticalInstant:Integer = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          else
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
          endif
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstant:Integer = iter.midCriticalInstant, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    endif
  else
    iter
  endif
).flag

--modified on 11/06/2015
def: checkPatternPrecedenceManyManyLeftExactlyMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:Integer, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let
  causeSize:Integer = causes->size(),
  effectSize:Integer = effects->size(),
  secondEffectDistance:Integer = effectDistances->at(2).value
in
subtrace->iterate(elem:trace::TraceElement;
  iter:Tuple(flag:Boolean, midCriticalInstants:Sequence(Integer), i1:Integer, causeCriticalInstant:Integer, i2:Integer, effectCriticalInstant:Integer)
  = Tuple{flag:Boolean = true, midCriticalInstants:Sequence(Integer) = Sequence{}, i1:Integer = 1, causeCriticalInstant:Integer = 0, i2:Integer = 1, effectCriticalInstant:Integer = 0}
  |
  if iter.flag then
    let e:String = elem.event.name in
    if e = causes->at(iter.i1) and self.compare(elem.timestamp.value, iter.causeCriticalInstant, causeDistances->at(iter.i1).which) then
      if iter.i1 = causeSize then
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->append(elem.timestamp.value+midDistance), i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      else
        let i11:Integer = iter.i1 + 1, nextCauseCriticalInstant:Integer = elem.timestamp.value + causeDistances->at(i11).value in
        if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then
          if iter.i2 = 1 then
            let t:Integer = elem.timestamp.value in
            if iter.midCriticalInstants->includes(t) then
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
            else
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
            endif
          else
            if iter.i2 = effectSize then
              Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
            else
              let i22:Integer = iter.i2 + 1 in
              Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
            endif
          endif
        else
          Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = i11, causeCriticalInstant:Integer = nextCauseCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
        endif
      endif
    else
      if e = effects->at(iter.i2) and self.compare(elem.timestamp.value, iter.effectCriticalInstant, effectDistances->at(iter.i2).which) then      
        if iter.i2 = 1 then
          let t:Integer = elem.timestamp.value in
          if iter.midCriticalInstants->includes(t) then
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants->select(subElem | subElem > t), i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
          else
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 2, effectCriticalInstant:Integer = t + secondEffectDistance}
          endif
        else
          if iter.i2 = effectSize then
            Tuple{flag:Boolean = false, midCriticalInstants:Sequence(Integer) = null, i1:Integer = null, causeCriticalInstant:Integer = null, i2:Integer = null, effectCriticalInstant:Integer = null}
          else
            let i22:Integer = iter.i2 + 1 in
            Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = i22, effectCriticalInstant:Integer = elem.timestamp.value + effectDistances->at(i22).value}
          endif
        endif
      else
        Tuple{flag:Boolean = iter.flag, midCriticalInstants:Sequence(Integer) = iter.midCriticalInstants, i1:Integer = 1, causeCriticalInstant:Integer = iter.causeCriticalInstant, i2:Integer = 1, effectCriticalInstant:Integer = iter.effectCriticalInstant}
      endif
    endif
  else
    iter
  endif
).flag

--modified on 12/06/2015
def: checkPatternPrecedenceManyManyLeftMidRight(subtrace:OrderedSet(trace::TraceElement), causes:Sequence(String), causeDistances:Sequence(Tuple(which:Integer, value:Integer)), midDistance:oclr::TimeDistance, effects:Sequence(String), effectDistances:Sequence(Tuple(which:Integer, value:Integer))):Boolean =
let midValue:Integer = midDistance.value, midWhich:oclr::ComparingOperator=midDistance.comparingOperator in
if midWhich = oclr::ComparingOperator::ATLEAST then
  self.checkPatternPrecedenceManyManyLeftAtLeastMidRight(subtrace, causes, causeDistances, midValue, effects, effectDistances)
else
  if midWhich = oclr::ComparingOperator::ATMOST then
    self.checkPatternPrecedenceManyManyLeftAtMostMidRight(subtrace, causes, causeDistances, midValue, effects, effectDistances)
  else
    self.checkPatternPrecedenceManyManyLeftExactlyMidRight(subtrace, causes, causeDistances, midValue, effects, effectDistances)
  endif
endif

def: checkPatternPrecedence(subtrace:OrderedSet(trace::TraceElement), pattern:oclr::Pattern):Boolean =
--check the satisfiability of the precedence pattern 'cause preceding effect'
--in the first event in the chain 'effect', it may contains time distance to the last event in the chain 'cause'
if subtrace->isEmpty() then
  true
else
  let orderPattern:oclr::OrderPattern = pattern.oclAsType(oclr::OrderPattern),
      causes:Sequence(String) = orderPattern.block1.event.name,
      causeDistances:Sequence(Tuple(which:Integer, value:Integer)) = self.loadDistances(orderPattern.block1.timeDistance),
      causeSize:Integer = causes->size(),
      effects:Sequence(String) = orderPattern.block2.event.name,
      effectDistances:Sequence(Tuple(which:Integer, value:Integer)) = self.loadDistances(orderPattern.block2.timeDistance),
      effectSize:Integer = effects->size()
  in
  if causeDistances->isEmpty() then
    if effectDistances->isEmpty() then
      if orderPattern.timeDistance->isEmpty() then
        if causeSize = 1 then
          let cause:String = causes->first() in
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.checkPatternPrecedenceOneOnePlain(subtrace, cause, effect)
          else
            self.checkPatternPrecedenceOneManyPlain(subtrace, cause, effects)
          endif
        else
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.checkPatternPrecedenceManyOnePlain(subtrace, causes, effect)
          else
            self.checkPatternPrecedenceManyManyPlain(subtrace, causes, effects)
          endif
        endif
      else
        if causeSize = 1 then
          let cause:String = causes->first() in
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.checkPatternPrecedenceOneOneMid(subtrace, cause, orderPattern.timeDistance, effect)
          else
            self.checkPatternPrecedenceOneManyMid(subtrace, cause, orderPattern.timeDistance, effects)
          endif
        else
          if effectSize = 1 then
            let effect:String = effects->first() in
            self.checkPatternPrecedenceManyOneMid(subtrace, causes, orderPattern.timeDistance, effect)
          else
            self.checkPatternPrecedenceManyManyMid(subtrace, causes, orderPattern.timeDistance, effects)
          endif
        endif
      endif
    else
      if orderPattern.timeDistance->isEmpty() then
        if causeSize = 1 then
          let cause:String = causes->first() in
          self.checkPatternPrecedenceOneManyRight(subtrace, cause, effects, effectDistances)
        else
          self.checkPatternPrecedenceManyManyRight(subtrace, causes, effects, effectDistances)
        endif
      else
        if causeSize = 1 then
          let cause:String = causes->first() in
          self.checkPatternPrecedenceOneManyMidRight(subtrace, cause, orderPattern.timeDistance, effects, effectDistances)
        else
          self.checkPatternPrecedenceManyManyMidRight(subtrace, causes, orderPattern.timeDistance, effects, effectDistances)
        endif
      endif
    endif
  else
    if effectDistances->isEmpty() then
      if orderPattern.timeDistance->isEmpty() then
        if effectSize = 1 then
          let effect:String = effects->first() in
          self.checkPatternPrecedenceManyOneLeft(subtrace, causes, causeDistances, effect)
        else
          self.checkPatternPrecedenceManyManyLeft(subtrace, causes, causeDistances, effects)
        endif
      else
        if effectSize = 1 then
          let effect:String = effects->first() in
          self.checkPatternPrecedenceManyOneLeftMid(subtrace, causes, causeDistances, orderPattern.timeDistance, effect)
        else
          self.checkPatternPrecedenceManyManyLeftMid(subtrace, causes, causeDistances, orderPattern.timeDistance, effects)
        endif
      endif
    else
      if orderPattern.timeDistance->isEmpty() then
        self.checkPatternPrecedenceManyManyLeftRight(subtrace, causes, causeDistances, effects, effectDistances)
      else
        self.checkPatternPrecedenceManyManyLeftMidRight(subtrace, causes, causeDistances, orderPattern.timeDistance, effects, effectDistances)
      endif
    endif
  endif 
endif

def: checkPatternExistence(subtrace:OrderedSet(trace::TraceElement), pattern:oclr::Pattern):Boolean =
--check the satisfiability of the existence pattern 'pattern'
if subtrace->isEmpty() then
  true
else
  let occPattern:oclr::OccurrencePattern = pattern.oclAsType(oclr::OccurrencePattern), eventName:String = occPattern.event.name, count:Integer = subtrace->select(elem | eventName = elem.event.name)->size() in
  if occPattern.comparingOperator->notEmpty() then
    let comparingOperator:oclr::ComparingOperator = occPattern.comparingOperator, n:Integer = occPattern.times in
    if oclr::ComparingOperator::ATLEAST = comparingOperator then
      count >= n
    else
      if oclr::ComparingOperator::ATMOST = comparingOperator then
        count <= n
      else
        count = n
      endif
    endif
  else
    count >= 1
  endif
endif

def: checkPatternAbsence(subtrace:OrderedSet(trace::TraceElement), pattern:oclr::Pattern):Boolean = 
--check the satisfiability of the absence pattern 'pattern'
if subtrace->isEmpty() then
  true
else
  let occPattern:oclr::OccurrencePattern = pattern.oclAsType(oclr::OccurrencePattern), eventName:String = occPattern.event.name, count:Integer = subtrace->select(elem | eventName = elem.event.name)->size() in
  if occPattern.comparingOperator->notEmpty() then
    let comparingOperator:oclr::ComparingOperator = occPattern.comparingOperator, n:Integer = occPattern.times in
    if oclr::ComparingOperator::EXACTLY = comparingOperator then
      count <> n
    else
      count = 0
    endif
  else
    count = 0
  endif
endif

def: checkPatternUniversality(subtrace:OrderedSet(trace::TraceElement), pattern:oclr::Pattern):Boolean = 
--check the satisfiability of the universality pattern 'always eventName'
let eventName:String = pattern.oclAsType(oclr::Universality).event.name in
subtrace->forAll(elem | eventName = elem.event.name)


endpackage